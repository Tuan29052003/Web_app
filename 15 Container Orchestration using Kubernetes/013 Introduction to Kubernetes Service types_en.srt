1
00:00:00,000 --> 00:00:06,000
As of now, we deployed all our microservices with the service type as LoadBalancer.

2
00:00:06,000 --> 00:00:14,000
Previously I told you that on high level LoadBalancer will expose all your microservices to the outside

3
00:00:14,000 --> 00:00:18,000
world, like all the applications who are staying outside of your cluster

4
00:00:18,000 --> 00:00:25,000
also, they can access your microservices. The same type LoadBalancer we have mentioned in all the microservices

5
00:00:25,000 --> 00:00:26,000
like under loans

6
00:00:26,000 --> 00:00:32,000
also, we have mentioned the same for Cards, for Gateway, for Eureka, for Keycloak and for config

7
00:00:32,000 --> 00:00:32,000
server.

8
00:00:32,000 --> 00:00:35,000
In all the places we have mentioned these type as LoadBalancer.

9
00:00:35,000 --> 00:00:42,000
But do you think this is a correct approach to expose all our services to outside of the cluster?

10
00:00:42,000 --> 00:00:47,000
Off course not, because all the clients who are trying to communicate with our microservice, they should

11
00:00:47,000 --> 00:00:54,000
only communicate through the gateway server, which is going to act as an edge server inside our microservice

12
00:00:54,000 --> 00:00:55,000
network.

13
00:00:55,000 --> 00:01:01,000
So we should only make our gateway server as a load balancer and all the remaining microservices,

14
00:01:01,000 --> 00:01:03,000
we should not use the LoadBalancer.

15
00:01:03,000 --> 00:01:08,000
But before we try to do that, we need to understand what are the other options that we have to expose

16
00:01:08,000 --> 00:01:13,000
our microservices within Kubernetes cluster or to outside of the Kubernetes cluster.

17
00:01:13,000 --> 00:01:16,000
So let's try to understand the same inside this lecture.

18
00:01:16,000 --> 00:01:24,000
Like you can see here inside Kubernetes, these are the three mostly are majorly used service types

19
00:01:24,000 --> 00:01:28,000
and these services are cluster IP nodeport and load balancer.

20
00:01:28,000 --> 00:01:31,000
As of now, we are using only LoadBalancer.

21
00:01:31,000 --> 00:01:38,000
So every microservice developer should aware about these three service types at a bare minimum, because

22
00:01:38,000 --> 00:01:44,000
without knowing the service type, the microservice developer cannot really understand how to expose

23
00:01:44,000 --> 00:01:48,000
a microservice to the outside of the cluster or within the cluster.

24
00:01:48,000 --> 00:01:53,000
So that's why we are going to do some good amount of discussion around these three service types.

25
00:01:53,000 --> 00:01:58,000
So the very first service type that I want to discuss here is cluster IP service type.

26
00:01:58,000 --> 00:02:06,000
So if you don't mention the service type inside your Kubernetes manifest file, then this is that default

27
00:02:06,000 --> 00:02:09,000
service that Kubernetes is going to consider.

28
00:02:09,000 --> 00:02:11,000
The name itself is self-explanatory.

29
00:02:11,000 --> 00:02:18,000
Whenever we are using ClusterIP service, the Kubernetes cluster is going to create an internal IP

30
00:02:18,000 --> 00:02:24,000
address that can be used for the internal communication within the Kubernetes cluster.

31
00:02:24,000 --> 00:02:31,000
So whenever we don't want to expose our microservice to the outside world or to the outside of the Kubernetes

32
00:02:31,000 --> 00:02:34,000
cluster, then we should use the cluster IP service.

33
00:02:34,000 --> 00:02:41,000
So here in the slide I clearly highlighted someone trying to send the external traffic and that is strictly

34
00:02:41,000 --> 00:02:47,000
not allowed because for the outside people, whatever cluster IP that we are going to get, it is not

35
00:02:47,000 --> 00:02:49,000
going to make any sense to them.

36
00:02:49,000 --> 00:02:56,000
They will simply get not reachable or unknown IP address, whereas other microservices or other applications

37
00:02:56,000 --> 00:02:58,000
within your container.

38
00:02:58,000 --> 00:03:02,000
They can try to communicate with your microservice with the help of cluster IP.

39
00:03:02,000 --> 00:03:05,000
So let's try to take an example of accounts

40
00:03:05,000 --> 00:03:11,000
microservice itself. If you see here under the service.yaml manifest file, I have mentioned the service

41
00:03:11,000 --> 00:03:14,000
type as ClusterIP. Under ports

42
00:03:14,000 --> 00:03:18,000
I have mentioned the port as 80 and the target port as 8080.

43
00:03:18,000 --> 00:03:25,000
So whenever we mention the target port as 8080, that means my accounts microservice is going to start

44
00:03:25,000 --> 00:03:33,000
at the port 8080 inside my accounts related pod but it is going to be exposed to the other clients

45
00:03:33,000 --> 00:03:36,000
inside the Kubernetes cluster at the Port 80.

46
00:03:36,000 --> 00:03:42,000
So that's why if you see here, I have two pods of accounts because I have mentioned the replicas as

47
00:03:42,000 --> 00:03:42,000
two.

48
00:03:42,000 --> 00:03:46,000
And inside these two parts, I have two different accounts

49
00:03:46,000 --> 00:03:51,000
microservices are running and both of them are started at the port, 8080.

50
00:03:51,000 --> 00:03:55,000
Usually these pods will be deployed in two different worker nodes.

51
00:03:55,000 --> 00:03:58,000
Like here I have worker node one and worker node two.

52
00:03:58,000 --> 00:04:03,000
But if you see here, whoever want to communicate with my accounts microservice, they should use

53
00:04:03,000 --> 00:04:09,000
the ClusterIP that is generated by the Kubernetes cluster or they can use the service name that we

54
00:04:09,000 --> 00:04:16,000
have mentioned inside the service Kubernetes manifest file. Along with the service name at the ClusterIP,

55
00:04:16,000 --> 00:04:16,000
.

56
00:04:16,000 --> 00:04:24,000
they should also forward the request at the Port 80 because we exposed all our accounts microservice

57
00:04:24,000 --> 00:04:30,000
related containers to the other applications inside the Kubernetes cluster at the Port 80. If needed

58
00:04:30,000 --> 00:04:37,000
you can also mention the port value as 8080, which is same as your target port or your container port.

59
00:04:37,000 --> 00:04:42,000
So if you see the beauty of Kubernetes here, suppose think like some other application inside your

60
00:04:42,000 --> 00:04:49,000
Kubernetes cluster is trying to send the internal traffic at Port 80 using ClusterIP or using service

61
00:04:49,000 --> 00:04:49,000
name.

62
00:04:49,000 --> 00:04:54,000
In this scenario, the Kubernetes is going to do the load balancing behind the scenes

63
00:04:54,000 --> 00:04:57,000
it will decide to which pod the request has to send.

64
00:04:57,000 --> 00:04:59,000
And once this decision took by the

65
00:05:00,000 --> 00:05:01,000
Kubernetes cluster,

66
00:05:01,000 --> 00:05:04,000
it is going to forward the request to the corresponding pod.

67
00:05:04,000 --> 00:05:09,000
So my other application inside the Kubernetes cluster, who is trying to invoke the accounts

68
00:05:09,000 --> 00:05:15,000
microservice, they don't have to know what is the actual pod or what is the actual worker node where

69
00:05:15,000 --> 00:05:20,000
my accounts microservice is deployed, they will simply invoke with the help of ClusterIP or with

70
00:05:20,000 --> 00:05:23,000
the help of service name, which is accounts.

71
00:05:23,000 --> 00:05:29,000
I hope you are clear about ClusterIP, so we should make all our microservices accept gateway server

72
00:05:29,000 --> 00:05:35,000
to use ClusterIP so that they are not exposed to the outside of the Kubernetes cluster.

73
00:05:35,000 --> 00:05:40,000
And this is one of the way of securing our microservices from the external traffic.

74
00:05:40,000 --> 00:05:48,000
So no unauthenticated user or unauthorized user, they can access our microservices if you make them

75
00:05:48,000 --> 00:05:49,000
as CusterIP service.

76
00:05:49,000 --> 00:05:54,000
Now let's try to understand the next service that we have, which is NodePort service.

77
00:05:54,000 --> 00:06:01,000
So whenever you mention that type as NodePort behind the scenes, the Kubernetes is going to automatically

78
00:06:01,000 --> 00:06:11,000
expose your container at a randomly generated NodePort, which is in the range of 30,000 to 32,767.

79
00:06:11,000 --> 00:06:11,000
.

80
00:06:11,000 --> 00:06:14,000
So let's try to deep dive into these NodePort service.

81
00:06:14,000 --> 00:06:20,000
Like you can see here, whenever we want to use the NodePort under the service manifest file, we need

82
00:06:20,000 --> 00:06:22,000
to mention the type as NodePort.

83
00:06:22,000 --> 00:06:27,000
And along with that you can mention what is a port, what is the target port and mentioning the NodePort

84
00:06:27,000 --> 00:06:30,000
value is completely optional.

85
00:06:30,000 --> 00:06:35,000
If you don't mention node port value, then a randomly generated node port value will be considered

86
00:06:35,000 --> 00:06:37,000
by the Kubernetes cluster.

87
00:06:37,000 --> 00:06:42,000
Here inside the service manifest file, I have mentioned the node port as 32593.

88
00:06:42,000 --> 00:06:49,000
That's why you can see both of my accounts microservices are exposed at the node port 32593.

89
00:06:49,000 --> 00:06:55,000
So this NodePort service will be exposed on top of the ClusterIP service.

90
00:06:55,000 --> 00:07:02,000
So if you try to understand first my accounts microservice are deployed at the port 8080 in 2 different

91
00:07:02,000 --> 00:07:06,000
worker nodes and using the cluster IP it exposed at the port 80.

92
00:07:06,000 --> 00:07:12,000
Now since I have mentioned the service type as NodePort, my Kubernetes cluster is going to accept

93
00:07:12,000 --> 00:07:18,000
the external traffic at the NodePort value that we have defined, which is 32593.

94
00:07:18,000 --> 00:07:23,000
So whoever wants to send a traffic to my accounts microservice first they should know that,

95
00:07:23,000 --> 00:07:28,000
what are the IP addresses are worker nodes that we have inside our Kubernetes cluster.

96
00:07:28,000 --> 00:07:31,000
So let's assume one of the external client application.

97
00:07:31,000 --> 00:07:34,000
They want to consume my accounts microservice.

98
00:07:34,000 --> 00:07:41,000
So then they need to send that traffic to the IP address of the worker node one or worker node two and

99
00:07:41,000 --> 00:07:42,000
post the IP address,

100
00:07:42,000 --> 00:07:45,000
they should mention the NodePort value, which is 32593.

101
00:07:45,000 --> 00:07:51,000
So once the traffic is received at this node port, my Kubernetes cluster is going to forward that request

102
00:07:51,000 --> 00:07:55,000
to the cluster IP address at the service name that we have defined.

103
00:07:55,000 --> 00:08:01,000
And from the cluster IP, the load balancing will distribute between the two different parts available

104
00:08:01,000 --> 00:08:03,000
in two different worker nodes.

105
00:08:03,000 --> 00:08:09,000
But there is a drawback here with this NodePort service, my external client applications, they should

106
00:08:09,000 --> 00:08:14,000
know what is the IP addresses of worker node one or worker Node two.

107
00:08:14,000 --> 00:08:16,000
Suppose think like there is a scenario.

108
00:08:16,000 --> 00:08:22,000
One of the worker node has some issues, then Kubernetes automatically can kill that worker node.

109
00:08:22,000 --> 00:08:26,000
And in the place of that worker node, it is going to bring a new worker node.

110
00:08:26,000 --> 00:08:29,000
That means it is going to get a new IP address.

111
00:08:29,000 --> 00:08:34,000
So in this kind of scenarios, the client applications should always update their worker node details

112
00:08:34,000 --> 00:08:36,000
or IP address details.

113
00:08:36,000 --> 00:08:40,000
So that's why most of the people, they don't use this NodePort service.

114
00:08:40,000 --> 00:08:44,000
Instead they will go to the LoadBalancer service.

115
00:08:44,000 --> 00:08:47,000
So let's try to understand how this is different from the NodePort.

116
00:08:47,000 --> 00:08:55,000
So this is very similar to NodePort, but on top of the NodePorts that we have exposed, the Kubernetes

117
00:08:55,000 --> 00:08:58,000
is going to provide you a load balancer.

118
00:08:58,000 --> 00:09:05,000
And this LoadBalancer will have a public IP address, which is never going to change until unless a

119
00:09:05,000 --> 00:09:07,000
Kubernetes admin is going to change.

120
00:09:07,000 --> 00:09:13,000
So the same public address can be mapped to a DNS name or to your domain name and to this domain name

121
00:09:13,000 --> 00:09:15,000
or to this public address.

122
00:09:15,000 --> 00:09:18,000
The client applications, they can send the traffic.

123
00:09:18,000 --> 00:09:23,000
So whenever my LoadBalancer, which is staying outside my Kubernetes cluster, is receiving the traffic,

124
00:09:23,000 --> 00:09:27,000
it will identify to which worker node it has to send the request.

125
00:09:27,000 --> 00:09:31,000
Suppose think like it decided to send the request to the worker node one.

126
00:09:31,000 --> 00:09:36,000
In that scenario, the request will be forwarded to the NodePort and from the node port the traffic

127
00:09:36,000 --> 00:09:44,000
will go to the ClusterIP and from ClusterIP it will eventually go to the accounts microservice container.

128
00:09:44,000 --> 00:09:47,000
So what is the advantage that we have with this Load Balancer?

129
00:09:47,000 --> 00:09:54,000
We can expose the traffic to the external world just like inside NodePort, but compared to NodePort

130
00:09:54,000 --> 00:09:59,000
LoadBalancer service has an advantage, which is it is going to provide a LoadBalancer,

131
00:10:00,000 --> 00:10:06,000
which is always going to have a public IP address which you can map to your domain name regardless of

132
00:10:06,000 --> 00:10:11,000
how many worker nodes you are trying to create inside your Kubernetes cluster or how many worker nodes

133
00:10:11,000 --> 00:10:13,000
you are trying to delete them.

134
00:10:13,000 --> 00:10:18,000
So regardless of whatever is happening inside your Kubernetes cluster, it is not going to impact your

135
00:10:18,000 --> 00:10:26,000
client application in any way because the LoadBalancer is always going to be static with the IP address

136
00:10:26,000 --> 00:10:27,000
at the domain name that you have mapped.

137
00:10:27,000 --> 00:10:31,000
And the same can be used by your client applications.

138
00:10:31,000 --> 00:10:36,000
And this LoadBalancer, whatever created by the Kubernetes cluster, it is always going to track what

139
00:10:36,000 --> 00:10:39,000
is happening inside the Kubernetes cluster.

140
00:10:39,000 --> 00:10:44,000
Right now I have two replicas of accounts microservice deployed into two worker nodes.

141
00:10:44,000 --> 00:10:49,000
If I try to increase the replicas to three, it may deploy it into another worker node.

142
00:10:49,000 --> 00:10:55,000
So all those details will be tracked by this LoadBalancer and the request accordingly will be distributed

143
00:10:55,000 --> 00:10:57,000
to the multiple worker nodes.

144
00:10:57,000 --> 00:11:03,000
With this, I'm assuming your super, super clear about the service types that we have inside the Kubernetes.

145
00:11:03,000 --> 00:11:07,000
Let's try to see the demo of these services in the next lecture.

146
00:11:07,000 --> 00:11:10,000
Thank you and I'll catch you in the next lecture bye.


1
00:00:00,000 --> 00:00:06,000
Before we try to make our hands dirty by deploying all our microservices into a Kubernetes cluster.

2
00:00:06,000 --> 00:00:11,000
First, let me try to explain you What is the internal structure of Kubernetes?

3
00:00:11,000 --> 00:00:17,000
What are the components inside Kubernetes that are responsible to do the magic of automated deployments,

4
00:00:17,000 --> 00:00:22,000
rollouts, scaling and many other advantages provided by the Kubernetes?

5
00:00:22,000 --> 00:00:27,000
Whenever I say Kubernetes, we are talking about a cluster.

6
00:00:27,000 --> 00:00:28,000
So what is a cluster?

7
00:00:28,000 --> 00:00:35,000
Inside cluster will have set of servers or virtual machines which are going to work together to deliver

8
00:00:35,000 --> 00:00:37,000
a desired output to the end user.

9
00:00:37,000 --> 00:00:40,000
So very similarly inside Kubernetes cluster

10
00:00:40,000 --> 00:00:48,000
also we will have various servers or virtual machines which are going to work together to make our microservices

11
00:00:48,000 --> 00:00:51,000
always running properly without any issues.

12
00:00:51,000 --> 00:00:56,000
Here you may have a question like why should we go with a complex setup of Kubernetes cluster?

13
00:00:56,000 --> 00:01:00,000
Can't we deploy all our microservices with the help of Docker compose alone?

14
00:01:00,000 --> 00:01:01,000
It's a very good question.

15
00:01:01,000 --> 00:01:05,000
We cannot deploy all our containers with the help of Docker compose.

16
00:01:05,000 --> 00:01:12,000
Whenever you are using Docker compose, you are going to deploy all your containers inside a single

17
00:01:12,000 --> 00:01:12,000
server.

18
00:01:12,000 --> 00:01:17,000
But in real production applications you may have hundreds of microservices.

19
00:01:17,000 --> 00:01:23,000
We cannot deploy all our hundreds of microservices with the help of Docker compose in a single server.

20
00:01:23,000 --> 00:01:30,000
Instead, we want to build and multi distributed environment where we can deploy our microservices in

21
00:01:30,000 --> 00:01:34,000
various servers are nodes inside a cluster.

22
00:01:34,000 --> 00:01:41,000
On top of that, your Docker or Docker compose is not capable of automatic deployments, rollouts,

23
00:01:41,000 --> 00:01:42,000
scaling.

24
00:01:42,000 --> 00:01:47,000
So that's why we need to leverage Kubernetes, which is a container orchestration.

25
00:01:47,000 --> 00:01:49,000
Here I have a meme for you.

26
00:01:49,000 --> 00:01:53,000
Like you can see, containers don't solve all problems.

27
00:01:53,000 --> 00:01:59,000
If you try to build your microservices only with the help of containers and dockers, this is what is

28
00:01:59,000 --> 00:02:02,000
going to happen. Because there is a lot of manual work involved.

29
00:02:02,000 --> 00:02:07,000
If you use only containers and docker inside your production environment.

30
00:02:07,000 --> 00:02:12,000
Now let's go back to our discussion around Kubernetes internal architecture.

31
00:02:12,000 --> 00:02:17,000
Like I said before, usually a Kubernetes cluster will have multiple nodes.

32
00:02:17,000 --> 00:02:23,000
Whenever we are talking about a Kubernetes cluster, your Kubernetes cluster will have two types of

33
00:02:23,000 --> 00:02:23,000
nodes.

34
00:02:23,000 --> 00:02:29,000
The very first one is Master Node, which is responsible to controlling and maintaining your entire

35
00:02:29,000 --> 00:02:30,000
Kubernetes cluster.

36
00:02:30,000 --> 00:02:37,000
Apart from Master Node, we also have worker nodes inside Kubernetes cluster. Like the name itself,

37
00:02:37,000 --> 00:02:38,000
Self-explanatory.

38
00:02:38,000 --> 00:02:44,000
These worker nodes are responsible to handle the traffic that we get towards our microservices.

39
00:02:44,000 --> 00:02:48,000
First, let's try to understand in detail about Master Node.

40
00:02:48,000 --> 00:02:49,000
Inside your master node,

41
00:02:49,000 --> 00:02:54,000
there is going to be a very good component, which is Kube API server.

42
00:02:54,000 --> 00:03:02,000
This Kube API server is going to expose some APIs using which anyone from outside Kubernetes cluster

43
00:03:02,000 --> 00:03:09,000
they can interact with the master node and using the same API server only the master nodes and worker

44
00:03:09,000 --> 00:03:10,000
nodes

45
00:03:10,000 --> 00:03:12,000
they are going to communicate with each other.

46
00:03:12,000 --> 00:03:17,000
So like you can see here on top of this slide, there are two approaches that we can follow whenever

47
00:03:17,000 --> 00:03:20,000
we want to interact with the Kubernetes cluster.

48
00:03:20,000 --> 00:03:24,000
The very first one is using admin UI of the Kubernetes.

49
00:03:24,000 --> 00:03:28,000
The other option is by using the kubectI CLI.

50
00:03:28,000 --> 00:03:35,000
So from your CLI terminal you can execute some kubectl commands and these commands will be input to

51
00:03:35,000 --> 00:03:37,000
the Kube API server.

52
00:03:37,000 --> 00:03:43,000
So with the help of Yaml configurations you can always provide some instructions to your Kubernetes

53
00:03:43,000 --> 00:03:49,000
cluster saying that I want so-and-so microservice to be deployed with so and so replicas with so and

54
00:03:49,000 --> 00:03:50,000
so docker image.

55
00:03:50,000 --> 00:03:57,000
So all those details we can provide as an input details inside a Yaml configuration to the master node

56
00:03:57,000 --> 00:04:01,000
with the help of kubectl CLI or admin UI.

57
00:04:01,000 --> 00:04:07,000
So these commands that we can give from outside of the Kubernetes cluster is going to be received by

58
00:04:07,000 --> 00:04:08,000
the Kube API server.

59
00:04:08,000 --> 00:04:15,000
So once my Kube API server receives instructions through kubectl CLI or admin UI, it is going to read

60
00:04:15,000 --> 00:04:16,000
the instructions.

61
00:04:16,000 --> 00:04:22,000
What is the end user is trying to do, whether he wants to create a deployment or whether he wants to

62
00:04:22,000 --> 00:04:23,000
do some autoscaling.

63
00:04:23,000 --> 00:04:29,000
So based upon the instructions that it understand it is going to give those instructions to the scheduler.

64
00:04:29,000 --> 00:04:36,000
So what is the purpose of scheduler component Scheduler will understand what are the requirements that

65
00:04:36,000 --> 00:04:44,000
it received from the Kube API server and based upon the requirements it is going to identify under which

66
00:04:44,000 --> 00:04:46,000
worker node it has to do a deployment.

67
00:04:46,000 --> 00:04:53,000
Suppose if my end user gave an instructions to the master node saying that I want to deploy my accounts

68
00:04:53,000 --> 00:04:54,000
to microservice.

69
00:04:54,000 --> 00:04:59,000
In such scenario, the kube API server will give these instructions to the scheduler. Scheduler

70
00:04:59,000 --> 00:05:07,000
is a component that is responsible to identify under which worker node the deployment of accounts

71
00:05:07,000 --> 00:05:08,000
microservice has to be done.

72
00:05:08,000 --> 00:05:13,000
So behind the scenes, it will do a lot of calculations like which worker node has bandwidth, which

73
00:05:13,000 --> 00:05:15,000
worker nodes is super busy.

74
00:05:15,000 --> 00:05:21,000
So by considering all these calculations, it is going to identify one of the worker node present inside

75
00:05:21,000 --> 00:05:23,000
the Kubernetes cluster.

76
00:05:23,000 --> 00:05:28,000
So here I only mentioned two worker nodes, but you may have any number of worker nodes inside your

77
00:05:28,000 --> 00:05:30,000
Kubernetes cluster.

78
00:05:30,000 --> 00:05:36,000
Once my scheduler identifies under which worker node it has to do the accounts microservice deployment,

79
00:05:36,000 --> 00:05:42,000
it is going to give the same instructions back to the Kube API server and from Kube API server it will

80
00:05:42,000 --> 00:05:48,000
reach to the corresponding worker node about the deployment of the accounts microservice.

81
00:05:48,000 --> 00:05:54,000
So now assume like your accounts microservice deployment is completed inside one of the worker node

82
00:05:54,000 --> 00:05:57,000
available, but the story is not going to end there.

83
00:05:57,000 --> 00:06:03,000
Maybe after few days or maybe after few hours, your container may have some problems.

84
00:06:03,000 --> 00:06:05,000
So who is going to track that?

85
00:06:05,000 --> 00:06:13,000
So it is the responsibility of the controller manager to always track the containers and worker nodes

86
00:06:13,000 --> 00:06:15,000
available inside the cluster.

87
00:06:15,000 --> 00:06:22,000
If any of the worker node or container is having some health issues, this controller manager is going

88
00:06:22,000 --> 00:06:29,000
to make sure it is bringing new worker nodes or new containers in the place of problematic containers

89
00:06:29,000 --> 00:06:30,000
are worker nodes.

90
00:06:30,000 --> 00:06:38,000
In simple words, we can say controller manager always have an input value saying that this is the desired

91
00:06:38,000 --> 00:06:40,000
state of my Kubernetes cluster.

92
00:06:40,000 --> 00:06:47,000
Inside my Kubernetes cluster, I always want to make sure I have three instances of accounts microservice

93
00:06:47,000 --> 00:06:48,000
running always.

94
00:06:48,000 --> 00:06:54,000
So my controller manager regularly keep health check of these three running instances of accounts

95
00:06:54,000 --> 00:07:00,000
microservice, If any of the worker node are if any of the container has issues, it is going to match

96
00:07:00,000 --> 00:07:02,000
with that desired state.

97
00:07:02,000 --> 00:07:05,000
Which means if one of the container is having some problems.

98
00:07:05,000 --> 00:07:11,000
Since my controller manager knows always three containers has to be in a good health status, it is

99
00:07:11,000 --> 00:07:17,000
going to kill the container which has some problems and in the same place it is going to bring the new

100
00:07:17,000 --> 00:07:19,000
container of accounts microservice.

101
00:07:19,000 --> 00:07:26,000
This way it will always try to match with the desired state that it received from the end user with

102
00:07:26,000 --> 00:07:29,000
the actual state present inside the Kubernetes cluster.

103
00:07:29,000 --> 00:07:36,000
Now, apart from controller manager, scheduler and Kube API server, we also have another important

104
00:07:36,000 --> 00:07:38,000
component, which is Etcd.

105
00:07:38,000 --> 00:07:39,000
So what is this

106
00:07:39,000 --> 00:07:39,000
etcd?

107
00:07:40,000 --> 00:07:48,000
We can say this etcd as a brain of our Kubernetes cluster. because this etcd is going to act as a database

108
00:07:48,000 --> 00:07:55,000
or a storage system for your Kubernetes cluster inside this etcd only all the information related to

109
00:07:55,000 --> 00:08:00,000
your Kubernetes cluster is going to stored as a key value pair.

110
00:08:00,000 --> 00:08:06,000
For example, if my controller manager at any point has some questions like how many replicas it has

111
00:08:06,000 --> 00:08:12,000
to maintain about accounts microservice, it can always connect with the etcd to understand what is

112
00:08:12,000 --> 00:08:16,000
the desired state that we initially received from the end user.

113
00:08:16,000 --> 00:08:21,000
And very similarly, the Kube API server when it receives the instructions from the end user with the

114
00:08:21,000 --> 00:08:28,000
help of CLI or  admin UI, it is going to make an entry into the etcd so the same values can be referred

115
00:08:28,000 --> 00:08:33,000
by the controller manager scheduler during their day to day operations.

116
00:08:33,000 --> 00:08:38,000
So this is what we have inside the master node now coming to the worker nodes like you can see, we

117
00:08:38,000 --> 00:08:40,000
have two worker nodes.

118
00:08:40,000 --> 00:08:44,000
So inside worker node also we have very good number of components.

119
00:08:44,000 --> 00:08:46,000
So let's try to understand what are those?

120
00:08:46,000 --> 00:08:51,000
The very first important component that I want to discuss here is Kubelet.

121
00:08:51,000 --> 00:08:52,000
So what is Kubelet?

122
00:08:52,000 --> 00:08:59,000
Kubelet is an agent running inside all your worker nodes using these Kubelet Only my master node is

123
00:08:59,000 --> 00:09:06,000
going to connect with the worker node and it is going to provide the instructions with the help of kube

124
00:09:06,000 --> 00:09:08,000
API server. Like we discussed previously,

125
00:09:08,000 --> 00:09:14,000
at the end of the day, all our microservices has to be deployed inside the worker node, so my master

126
00:09:14,000 --> 00:09:19,000
node has to give instructions to the worker node saying that please deploy this accounts microservice

127
00:09:19,000 --> 00:09:21,000
with a replica of three.

128
00:09:21,000 --> 00:09:26,000
So all such instructions the worker nodes are going to receive with the help of Kubelet.

129
00:09:27,000 --> 00:09:29,000
After Kubelet we have container runtime.

130
00:09:29,000 --> 00:09:31,000
So what is the purpose of container runtime?

131
00:09:31,000 --> 00:09:32,000
It is very simple.

132
00:09:32,000 --> 00:09:37,000
Since we are going to deploy all our microservices in the form of containers, we need to make sure

133
00:09:37,000 --> 00:09:41,000
there is some container runtime installed inside the worker node.

134
00:09:41,000 --> 00:09:47,000
Most of the times the container runtime is going to be Docker because that is the most widely used container

135
00:09:47,000 --> 00:09:48,000
environments.

136
00:09:48,000 --> 00:09:54,000
So when you try to set up Kubernetes cluster, all your worker nodes, they are going to have that Docker

137
00:09:54,000 --> 00:09:55,000
server installed inside them.

138
00:09:55,000 --> 00:09:59,000
Now behind that container runtime, you can see we have Pod.

139
00:09:59,000 --> 00:09:59,000
So what is a pod?

140
00:09:59,000 --> 00:10:00,000
Pod 

141
00:10:00,000 --> 00:10:07,000
is a smallest deployment unit inside the Kubernetes like worker node is going to be a jumbo server

142
00:10:08,000 --> 00:10:09,000
or a jumbo virtual machine.

143
00:10:09,000 --> 00:10:13,000
We cannot deploy our containers directly into the worker nodes.

144
00:10:13,000 --> 00:10:18,000
Instead, the Kubernetes is going to create a pod inside a worker node.

145
00:10:18,000 --> 00:10:24,000
And inside this pod only the actual containers of the microservices are going to be deployed.

146
00:10:24,000 --> 00:10:28,000
So what is the reason to have the pods inside Kubernetes cluster?

147
00:10:28,000 --> 00:10:29,000
It is very simple.

148
00:10:29,000 --> 00:10:35,000
Suppose if you are trying to deploy multiple microservices into your same worker node to provide that

149
00:10:35,000 --> 00:10:41,000
isolation from other microservices, we are going to have a concept of pods.

150
00:10:41,000 --> 00:10:45,000
So inside these parts only the containers will be deployed.

151
00:10:45,000 --> 00:10:49,000
Usually most of the times a pod will have a single container.

152
00:10:49,000 --> 00:10:55,000
Suppose think like you are trying to deploy your accounts, microservice and card microservice and loans

153
00:10:55,000 --> 00:10:56,000
microservice.

154
00:10:56,000 --> 00:11:03,000
All these microservices are going to be deployed independently in different, different parts.

155
00:11:03,000 --> 00:11:06,000
They will never be a scenario inside a single pod,

156
00:11:06,000 --> 00:11:09,000
multiple microservices will be deployed.

157
00:11:09,000 --> 00:11:16,000
Always remember inside a pod, only a specific microservice or a specific application only allowed.

158
00:11:16,000 --> 00:11:22,000
But here you may have question like for some parts I have mentioned two containers like container one

159
00:11:22,000 --> 00:11:23,000
and container two.

160
00:11:23,000 --> 00:11:29,000
So the reason sometimes you may deploy multiple containers inside a pod is sometimes your application

161
00:11:29,000 --> 00:11:32,000
container like accounts, loans or cards.

162
00:11:32,000 --> 00:11:39,000
It may need some helper container or it may need some utility container to perform its job.

163
00:11:39,000 --> 00:11:46,000
So such helper containers we can deploy inside the same pod where we have the main container.

164
00:11:46,000 --> 00:11:53,000
So this kind of deploying a helper container along with the main container inside a pod is called sidecar

165
00:11:53,000 --> 00:11:53,000
pattern.

166
00:11:53,000 --> 00:11:58,000
We are going to discuss about sidecar pattern in the coming lectures, but for now please note that

167
00:11:58,000 --> 00:12:05,000
always Kubernetes will make sure there is only one container inside a pod which is related to a single

168
00:12:05,000 --> 00:12:07,000
microservice application.

169
00:12:07,000 --> 00:12:09,000
Now the story is all going good

170
00:12:09,000 --> 00:12:14,000
like we'll give instructions to the master node and the master node is going to work with the scheduler

171
00:12:14,000 --> 00:12:20,000
controller manager and etcd and post that it is going to give instructions to the worker node through

172
00:12:20,000 --> 00:12:25,000
kubelet saying that I want so-and-so microservice to be deployed as a container.

173
00:12:25,000 --> 00:12:32,000
The same will be deployed as a container into a pod. But to expose your container to the outside world

174
00:12:32,000 --> 00:12:38,000
or to the other containers inside the same cluster, Kubernetes is going to use a component called Kube

175
00:12:38,000 --> 00:12:40,000
Proxy. With the help of Kube proxy

176
00:12:40,000 --> 00:12:44,000
only all the containers available inside the worker nodes.

177
00:12:44,000 --> 00:12:48,000
They are going to expose themselves to the outside world.

178
00:12:48,000 --> 00:12:53,000
Or they can also restrict themselves that the communication they are going to accept only within the

179
00:12:53,000 --> 00:12:54,000
cluster.

180
00:12:54,000 --> 00:12:58,000
So this is the full story of the Kubernetes internal architecture.

181
00:12:58,000 --> 00:13:02,000
I know you may have some questions, confusion, so don't worry.

182
00:13:02,000 --> 00:13:08,000
When we try to create Kubernetes cluster and try to deploy all our microservices into the Kubernetes

183
00:13:08,000 --> 00:13:11,000
cluster, then it is going to make sense for you.

184
00:13:11,000 --> 00:13:17,000
As of now, you can see we have a single master node and two worker nodes, but you can have any number

185
00:13:17,000 --> 00:13:19,000
of master nodes and any number of worker nodes.

186
00:13:19,000 --> 00:13:24,000
So this is very similar to the way how we work inside our projects.

187
00:13:24,000 --> 00:13:29,000
Think like there are ten developers who are going to do the actual work of development.

188
00:13:29,000 --> 00:13:32,000
So to manage all these developers will have a manager.

189
00:13:32,000 --> 00:13:37,000
So very similarly here also the master node is going to manage a set of worker nodes.

190
00:13:38,000 --> 00:13:43,000
If you have large number of worker nodes, then obviously we need more number of master nodes.

191
00:13:43,000 --> 00:13:49,000
A single master node cannot handle any number of worker nodes. And all the information that we discuss

192
00:13:49,000 --> 00:13:52,000
also mentioned them in these slides.

193
00:13:52,000 --> 00:13:58,000
You can always refer them in future whenever you are trying to quickly refresh the concept of Kubernetes.

194
00:13:58,000 --> 00:14:04,000
I tried to give the details about each and every component inside the master node, so the other name

195
00:14:04,000 --> 00:14:07,000
for the master node is Control Plane.

196
00:14:07,000 --> 00:14:10,000
That's what I highlighted on the top of the slide as well.

197
00:14:10,000 --> 00:14:15,000
Very similarly, inside the next slide, I provided the details about the components of worker node.

198
00:14:15,000 --> 00:14:16,000
What is Kubelet,

199
00:14:16,000 --> 00:14:18,000
what is Kube proxy,

200
00:14:18,000 --> 00:14:19,000
what is the container runtime,

201
00:14:19,000 --> 00:14:20,000
what is a pod,

202
00:14:20,000 --> 00:14:21,000
what is a worker node?

203
00:14:21,000 --> 00:14:23,000
So all these details are available.

204
00:14:23,000 --> 00:14:29,000
So my recommendation is please try to revise them one more time before you try to come to the next lecture.

205
00:14:29,000 --> 00:14:32,000
So that things will be super, super clear for you.

206
00:14:32,000 --> 00:14:33,000
Thank you.

207
00:14:33,000 --> 00:14:35,000
And I'll catch you in the next lecture bye.


1
00:00:00,000 --> 00:00:05,000
In the previous lecture, I gave a very quick introduction about resiliency inside microservices.

2
00:00:05,000 --> 00:00:12,000
Now, inside this lecture, let me give a typical scenario that we may face inside microservices, so

3
00:00:12,000 --> 00:00:19,000
that you will better understand what is fault tolerance and why we should make our microservices resilient

4
00:00:19,000 --> 00:00:22,000
to the problems that we may face on day to day basis.

5
00:00:22,000 --> 00:00:28,000
Like you can see here, we have Edge Server or API gateway that accepts the external traffic from

6
00:00:28,000 --> 00:00:29,000
the clients.

7
00:00:29,000 --> 00:00:35,000
If you recall, inside our microservices network, we have an REST API available inside the accounts

8
00:00:35,000 --> 00:00:39,000
microservice with the path fetchCustomerDetails.

9
00:00:39,000 --> 00:00:45,000
Whenever someone is trying to invoke this API, they are expecting the complete details of the customer.

10
00:00:45,000 --> 00:00:47,000
Like what are the customer details,

11
00:00:47,000 --> 00:00:50,000
what are his loans and cards details. For the same,

12
00:00:50,000 --> 00:00:53,000
initially my gateway server at the edge server.

13
00:00:53,000 --> 00:00:59,000
It is going to forward the request to the accounts microservice. My accounts microservice will have details

14
00:00:59,000 --> 00:01:04,000
about only accounts and customer, but it will not have details around loans and cards.

15
00:01:04,000 --> 00:01:05,000
microservice.

16
00:01:05,000 --> 00:01:11,000
That's why it is going to depend on other microservices like loans and cards microservice to fetch the

17
00:01:11,000 --> 00:01:13,000
respective information.

18
00:01:13,000 --> 00:01:19,000
Once it fetch the information from other microservice, it is going to aggregate or collate all the

19
00:01:19,000 --> 00:01:23,000
response and send the complete information to the edge server from Edge Server.

20
00:01:23,000 --> 00:01:26,000
It will reach to the client applications.

21
00:01:26,000 --> 00:01:27,000
So this is a typical scenario.

22
00:01:27,000 --> 00:01:33,000
Now think like in this scenario, one of the microservice which is participating inside this flow is

23
00:01:33,000 --> 00:01:35,000
not working properly.

24
00:01:35,000 --> 00:01:37,000
Or maybe it is trying to handle too many requests.

25
00:01:37,000 --> 00:01:40,000
That's why it is trying to respond very slowly.

26
00:01:40,000 --> 00:01:42,000
So the problem can be anything.

27
00:01:42,000 --> 00:01:45,000
So let's try to understand what will happen due to this issue.

28
00:01:45,000 --> 00:01:50,000
Here I just highlighted or assumed that cards microservice has some issues.

29
00:01:50,000 --> 00:01:53,000
That's why you can see there is a warning symbol on top of the cards

30
00:01:53,000 --> 00:02:00,000
microservice. When my accounts microservice invoke cards microservice to get the cards details for a

31
00:02:00,000 --> 00:02:05,000
particular customer, it is not going to get the response in an expected time frame.

32
00:02:05,000 --> 00:02:10,000
Maybe it is taking too long or my cards microservice is never responding.

33
00:02:10,000 --> 00:02:15,000
Assume like in a typical successful scenario, your accounts microservice will receive the response

34
00:02:15,000 --> 00:02:18,000
from the cards microservice within less than a second.

35
00:02:18,000 --> 00:02:24,000
But in this scenario, since cards microservice is not working properly or it is responding very slowly.

36
00:02:24,000 --> 00:02:29,000
Maybe it took around 10s or even after 10s it is not responding.

37
00:02:29,000 --> 00:02:32,000
So these 10s inside my accounts

38
00:02:32,000 --> 00:02:33,000
microservice,

39
00:02:33,000 --> 00:02:39,000
there will be a thread which will wait for my cards microservice response or there might be some resources

40
00:02:39,000 --> 00:02:43,000
like memory CPU usage allocated inside my accounts

41
00:02:43,000 --> 00:02:45,000
microservice to invoke the cards microservice.

42
00:02:45,000 --> 00:02:52,000
So here my accounts microservice waited for more than 10s which means for a single request

43
00:02:52,000 --> 00:02:56,000
If you are making your accounts microservice to wait for more than 10s,

44
00:02:56,000 --> 00:03:01,000
and if the same thing happens for all the remaining requests coming from the external clients, you

45
00:03:01,000 --> 00:03:07,000
can imagine due to cards microservice performance issues, it is going to have a ripple effect on accounts

46
00:03:07,000 --> 00:03:08,000
microservice.

47
00:03:08,000 --> 00:03:13,000
Now since accounts microservice is waiting for a long time for cards response.

48
00:03:13,000 --> 00:03:19,000
Without my accounts, microservice is also going to respond slowly to the edge server.

49
00:03:19,000 --> 00:03:25,000
Now the ripple effect went to Edge server as well, so the edge server will keep keep waiting and with

50
00:03:25,000 --> 00:03:31,000
that there will be too many threads, there will be too many resources being consumed on the edge server

51
00:03:31,000 --> 00:03:31,000
as well.

52
00:03:31,000 --> 00:03:36,000
So this will also impact the performance of your edge server.

53
00:03:36,000 --> 00:03:42,000
And with that, all the traffic coming towards your edge server from external client applications not

54
00:03:42,000 --> 00:03:47,000
only for fetchCustomerDetails for other APIs also is going to get impacted.

55
00:03:47,000 --> 00:03:53,000
So this is a proper or typical or most common scenario that may happen inside your microservices.

56
00:03:53,000 --> 00:03:59,000
You can see one microservice, which is having a problem, is creating ripple effects throughout your

57
00:03:59,000 --> 00:04:01,000
microservice network.

58
00:04:01,000 --> 00:04:05,000
So this is what we need to avoid with the help of resiliency patterns.

59
00:04:05,000 --> 00:04:08,000
So let's try to understand how to overcome this challenge.

60
00:04:08,000 --> 00:04:15,000
So to handle these kind of scenarios only we can use one of the resiliency pattern which is secured

61
00:04:15,000 --> 00:04:16,000
breaker pattern.

62
00:04:16,000 --> 00:04:21,000
I hope you are clear about this typical scenario, and I know you may have questions like how secure

63
00:04:21,000 --> 00:04:23,000
Breaker is going to handle this scenario.

64
00:04:23,000 --> 00:04:26,000
I'm going to explain you that from the next lecture.

65
00:04:26,000 --> 00:04:29,000
Thank you and I'll catch you in the next lecture bye.


1
00:00:00,000 --> 00:00:06,000
Now, inside this lecture, let's try to create a new rest API inside accounts microservice that will

2
00:00:06,000 --> 00:00:13,000
help us to delete the existing customer and account details and how I'm going to support this API is

3
00:00:13,000 --> 00:00:15,000
my client application

4
00:00:15,000 --> 00:00:20,000
they have to invoke my delete API along with the mobile number. Based upon the given mobile number

5
00:00:20,000 --> 00:00:23,000
I Will try to load the customer entity details from the database.

6
00:00:23,000 --> 00:00:25,000
From the Customer entity.

7
00:00:25,000 --> 00:00:31,000
I'll be getting customerId, using customerId, I'm going to delete the records present in both tables,

8
00:00:31,000 --> 00:00:38,000
which is inside the accounts and customer because both tables have this common column, which is customerId.

9
00:00:38,000 --> 00:00:40,000
So let's do the same for the same.

10
00:00:40,000 --> 00:00:44,000
First, I need to create a new method inside my IAccountService interface.

11
00:00:44,000 --> 00:00:46,000
So let me create a new method here.

12
00:00:46,000 --> 00:00:49,000
So this is the new method with the name deleteAccount().

13
00:00:49,000 --> 00:00:54,000
And this is also going to return a boolean value saying that if the delete operation is successful or

14
00:00:54,000 --> 00:01:00,000
not and it is going to accept the mobile number as an input parameter. Now we can go to the AccountService

15
00:01:00,000 --> 00:01:04,000
and I'm going to put the cursor where I want my method to be generated.

16
00:01:04,000 --> 00:01:11,000
Now I'll go to the top and I'll run this error and click on this implement methods and click okay.

17
00:01:11,000 --> 00:01:14,000
So this will generate a new empty method inside deleteAccount().

18
00:01:14,000 --> 00:01:19,000
So now, quickly, I'm going to paste a few lines of code which we can discuss, and this is going to

19
00:01:19,000 --> 00:01:20,000
be super, super easy.

20
00:01:20,000 --> 00:01:27,000
The reason why I'm saying easy is it's always easy to destroy, to delete something, but it's very

21
00:01:27,000 --> 00:01:30,000
hard to create something from scratch.

22
00:01:30,000 --> 00:01:34,000
That's why I always feel like deleting something is very easy.

23
00:01:34,000 --> 00:01:37,000
Now here I'm pasting few lines of code.

24
00:01:37,000 --> 00:01:43,000
First, I'm trying to fetch the customer details based upon the findByMobileNumber() method available

25
00:01:43,000 --> 00:01:47,000
inside CustomerRepository to this method we're passing mobile number as input.

26
00:01:47,000 --> 00:01:51,000
If there is no record exist, we are throwing the ResourceNotFoundException.

27
00:01:51,000 --> 00:01:56,000
Now I have Customer entity in my hand with this Customer entity

28
00:01:56,000 --> 00:02:02,000
I'm going to get the customerId and with the help of this AccountRepository and CustomerRepository,

29
00:02:02,000 --> 00:02:07,000
I'm going to invoke this methods deleteById() and deleteByCustomerId().

30
00:02:07,000 --> 00:02:11,000
So this deleteById() is available from the framework.

31
00:02:11,000 --> 00:02:16,000
If you see this method available inside the crud repository belongs to the framework.

32
00:02:16,000 --> 00:02:22,000
So what this method is going to do is it is going to delete the record based upon the primary key value.

33
00:02:22,000 --> 00:02:28,000
Since inside the customer table the primary key is customerId, we are able to invoke the deleteById()

34
00:02:28,000 --> 00:02:30,000
But for the account table

35
00:02:30,000 --> 00:02:35,000
In order to invoke the deleteById(), we should pass the what is the account number so I can fetch the

36
00:02:35,000 --> 00:02:42,000
account number by firing a query again on top of the accounts table, but it is unnecessary firing of

37
00:02:42,000 --> 00:02:42,000
a query.

38
00:02:42,000 --> 00:02:43,000
Instead,

39
00:02:43,000 --> 00:02:49,000
I will try to delete the record based upon the customerId column present inside the accounts table.

40
00:02:49,000 --> 00:02:55,000
Since this customerId is not a primary key inside the accounts table, we need to write this method

41
00:02:55,000 --> 00:02:57,000
inside the AccountsRepository.

42
00:02:57,000 --> 00:03:03,000
So here I'm going to create this method which which will return void and the method name is deleteByCustomerId

43
00:03:03,000 --> 00:03:09,000
and it is going to accept customerId value as an input.

44
00:03:09,000 --> 00:03:15,000
With this my Spring Data JPA Behind the scenes it is going to generate a delete query just like

45
00:03:15,000 --> 00:03:23,000
findBy() indicates select query deleteBy indicates to prepare a delete query to the spring data JPA framework

46
00:03:23,000 --> 00:03:26,000
and here the column name that we want to consider is customerId.

47
00:03:26,000 --> 00:03:32,000
That's why I have to mention the same field name present inside the Accounts entity like this is the

48
00:03:32,000 --> 00:03:36,000
customerId, the same field name I have mentioned here.

49
00:03:36,000 --> 00:03:37,000
Now here there is a catch.

50
00:03:37,000 --> 00:03:43,000
With the help of our custom methods, we are trying to change the data inside the database.

51
00:03:43,000 --> 00:03:45,000
Previously we are only trying to read the data.

52
00:03:45,000 --> 00:03:51,000
It is not going to change the data in any way, but whenever you are trying to update or delete with

53
00:03:51,000 --> 00:03:56,000
the custom methods that you have written, we need to make sure we are mentioning two annotations on

54
00:03:56,000 --> 00:03:58,000
top of these abstract methods.

55
00:03:58,000 --> 00:04:05,000
These two annotations are @Transactional and the second annotation is @Modifying.

56
00:04:05,000 --> 00:04:11,000
Modifying will tell to the spring data JPA framework that these method is going to modify the data.

57
00:04:11,000 --> 00:04:18,000
So that's why please execute the query of this method inside a Transaction.

58
00:04:18,000 --> 00:04:21,000
That's why we are mentioning Transactional annotation.

59
00:04:21,000 --> 00:04:27,000
When my spring data JPA runs my query inside a Transaction and if there is some error happens at the

60
00:04:27,000 --> 00:04:34,000
runtime, any partial change of data that is resulted due to the queries will be rolled back because

61
00:04:34,000 --> 00:04:39,000
the entire transaction will be rolled back by the spring data JPA and we are in safe hands.

62
00:04:39,000 --> 00:04:44,000
It should not be a scenario where like we deleted the account but not the customer.

63
00:04:44,000 --> 00:04:50,000
So those kind of scenarios we need to make sure we are handling with the help of this transactional

64
00:04:50,000 --> 00:04:51,000
and modifying.

65
00:04:51,000 --> 00:04:57,000
And here you may have a question like we are also invoking these deleteById method inside the

66
00:04:57,000 --> 00:04:59,000
CustumerRepository then why you are not mentioning

67
00:04:59,000 --> 00:05:02,000
Transactional and Modifying for this method.

68
00:05:02,000 --> 00:05:05,000
Please note that this method is from the framework.

69
00:05:05,000 --> 00:05:07,000
Framework is going to take care of it.

70
00:05:07,000 --> 00:05:13,000
But this method we have returned with our own hands since framework cannot identify that.

71
00:05:13,000 --> 00:05:20,000
We need to let framework that this method is going to modify data and please run it inside a Transaction.

72
00:05:20,000 --> 00:05:23,000
And if there is some error happen, please roll back the Transaction.

73
00:05:23,000 --> 00:05:27,000
That's what we are trying to communicate with these two annotations.

74
00:05:27,000 --> 00:05:32,000
Once the delete operation is completed, we are simply returning true post that I can go to the controller

75
00:05:32,000 --> 00:05:34,000
class inside controller class

76
00:05:34,000 --> 00:05:37,000
also, I'm going to create a new method.

77
00:05:37,000 --> 00:05:40,000
So here I'm pasting the new method just to save some time.

78
00:05:40,000 --> 00:05:43,000
So like you can see the annotation is @DeleteMapping.

79
00:05:43,000 --> 00:05:50,000
We need to use delete() method only to delete the data and the API path that it is going to support is

80
00:05:50,000 --> 00:05:51,000
/delete.

81
00:05:51,000 --> 00:05:52,000
The method name is deleteAccountDetails().

82
00:05:52,000 --> 00:05:57,000
It is going to accept mobile number and we are invoking the deleteAccount() method available inside the

83
00:05:57,000 --> 00:06:00,000
service layer and we're accepting a boolean.

84
00:06:00,000 --> 00:06:06,000
If the boolean is true, we are sending a ok response with the status 200 and the message has request to

85
00:06:06,000 --> 00:06:07,000
process successfully.

86
00:06:07,000 --> 00:06:13,000
But for some reason, if this boolean is false, we are sending these error saying that 500 is a code

87
00:06:13,000 --> 00:06:15,000
and the message has an error occurred.

88
00:06:15,000 --> 00:06:18,000
Please try again or contact dev team.

89
00:06:18,000 --> 00:06:20,000
So with this we should be good.

90
00:06:20,000 --> 00:06:21,000
Let me save this changes.

91
00:06:21,000 --> 00:06:28,000
Do a build like you know the build will restart my application and all the data will be lost inside

92
00:06:28,000 --> 00:06:29,000
the database.

93
00:06:29,000 --> 00:06:31,000
But don't worry, we can quickly create the data.

94
00:06:31,000 --> 00:06:37,000
I know this is very annoying step right now, but later on when we move to a proper MySQL database,

95
00:06:37,000 --> 00:06:39,000
that is going to be super, super helpful.

96
00:06:39,000 --> 00:06:42,000
So first I'm creating the new account.

97
00:06:42,000 --> 00:06:43,000
I'm taking the same mobile number.

98
00:06:43,000 --> 00:06:50,000
I'll validate if the account details are present by invoking this get method so the details are created.

99
00:06:50,000 --> 00:06:52,000
That's why I'm getting the successful response.

100
00:06:52,000 --> 00:06:57,000
Now I'll go to this deleteAccountDetails() and the path that we need to invoke is /api/delete

101
00:06:57,000 --> 00:07:03,000
delete with the Http method as delete and we need to pass a query param mobile number with the

102
00:07:03,000 --> 00:07:05,000
same mobile number value.

103
00:07:05,000 --> 00:07:09,000
As soon as I click delete you can see I'm getting a successful response.

104
00:07:09,000 --> 00:07:09,000
Now,

105
00:07:09,000 --> 00:07:17,000
If we go and check the fetch API you will get not found error because the data is deleted successfully.

106
00:07:17,000 --> 00:07:22,000
Now coming to the native scenario, I can try to invoke the delete API again.

107
00:07:22,000 --> 00:07:27,000
You can see right now my delete API also throwing not found because there is no such data.

108
00:07:27,000 --> 00:07:27,000
Hooray.

109
00:07:28,000 --> 00:07:32,000
We completed all the four crud operations inside our Accounts

110
00:07:32,000 --> 00:07:34,000
Microservice, I hope you are clear.

111
00:07:34,000 --> 00:07:35,000
Take a break.

112
00:07:35,000 --> 00:07:38,000
Take your favorite drink, coffee, whatever you want,

113
00:07:38,000 --> 00:07:38,000
come back.

114
00:07:38,000 --> 00:07:45,000
We are yet to discuss more standards like proper RuntimException handling auditing of the metadata

115
00:07:45,000 --> 00:07:49,000
columns with the help of spring data JPA documenting the REST APIs.

116
00:07:49,000 --> 00:07:52,000
So these three important topics we need to discuss.

117
00:07:52,000 --> 00:07:54,000
I hope you are excited.

118
00:07:54,000 --> 00:07:55,000
I'm also super excited.

119
00:07:55,000 --> 00:07:59,000
I'm going to take a small break and catch you in the next lecture bye.


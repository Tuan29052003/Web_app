1
00:00:00,000 --> 00:00:07,000
Now inside this lecture, let's try to create a REST API that will help to fetch the account and customer

2
00:00:07,000 --> 00:00:13,000
details present inside the database by accepting the mobile number as an input.

3
00:00:13,000 --> 00:00:19,000
Any end user or client application, they'll pass the mobile number to our REST API and based upon the

4
00:00:19,000 --> 00:00:24,000
data present inside the database, it is going to send all the customer and bank account details. For

5
00:00:24,000 --> 00:00:25,000
the same

6
00:00:25,000 --> 00:00:28,000
First, we need to create a new method inside the AccountsController.

7
00:00:28,000 --> 00:00:36,000
So the method access type is going to be public and we are going to send the customer DTO as a response.

8
00:00:36,000 --> 00:00:42,000
So let me mention customer DTO inside the response entity and the method name is going to be 

9
00:00:42,000 --> 00:00:43,000
fetchAccountDetails().

10
00:00:43,000 --> 00:00:50,000
And to this method we need to pass the annotation which is @RequestParam because since we

11
00:00:50,000 --> 00:00:55,000
are trying to accept only one request value which is mobile number with the help of query params, we

12
00:00:55,000 --> 00:01:00,000
need to make sure we are mentioning @RequestParam here and post that space followed by string,

13
00:01:00,000 --> 00:01:04,000
followed by mobile number which is the field name.

14
00:01:04,000 --> 00:01:09,000
Now inside this method I can write all the business logic, but before that I need to make sure I'm

15
00:01:09,000 --> 00:01:16,000
mentioning the GetMapping annotation on top of this method because this method is going to help you

16
00:01:16,000 --> 00:01:20,000
to fetch the resource details from the database.

17
00:01:20,000 --> 00:01:26,000
That's why we need to use the get mapping whenever we are trying to read the data and the API path that

18
00:01:26,000 --> 00:01:29,000
this method is going to support is /fetch.

19
00:01:29,000 --> 00:01:35,000
So whenever someone is trying to invoke the path, which is API /fetch, this method will be invoked.

20
00:01:35,000 --> 00:01:41,000
Now as a next step, we need to go to the IAccountService and here we need to create one new abstract

21
00:01:41,000 --> 00:01:46,000
method with the name fetchAccount() that is going to accept the mobile number as the input parameter

22
00:01:46,000 --> 00:01:50,000
and going to return customer DTO as an output object.

23
00:01:50,000 --> 00:01:55,000
So once we define this abstract method, the very next step, obviously we need to go to the 

24
00:01:55,000 --> 00:02:00,000
AccountServiceImpl  and we need to make sure we are implementing the method.

25
00:02:00,000 --> 00:02:02,000
There will be an error like you can see here.

26
00:02:02,000 --> 00:02:07,000
Let's hover on that and click on this implement methods and click okay.

27
00:02:07,000 --> 00:02:09,000
The empty fetch account method created.

28
00:02:09,000 --> 00:02:14,000
Let me take this method and paste this after this Create new account method.

29
00:02:14,000 --> 00:02:16,000
That's where we have a proper sequence.

30
00:02:16,000 --> 00:02:22,000
So now inside this fetchAccount() method, we need to write a logic to fetch the account details and

31
00:02:22,000 --> 00:02:25,000
customer details from the database.

32
00:02:25,000 --> 00:02:30,000
But when we try to fetch the details from the database based upon a mobile number, there is a good

33
00:02:30,000 --> 00:02:34,000
chance there might be no customer, no account details for a given mobile number.

34
00:02:34,000 --> 00:02:40,000
In such scenarios, we should be able to throw an custom business exception For the same, we need to

35
00:02:40,000 --> 00:02:47,000
go to the exception package and here, just like customer already exception, I'm going to create a

36
00:02:47,000 --> 00:02:51,000
new exception with the name ResourceNotFound exception.

37
00:02:51,000 --> 00:02:57,000
So let me create this class and here instead of bad request, I'm going to mention the Http status as

38
00:02:57,000 --> 00:03:03,000
not found because we are trying to throw an business error saying that so and so resource is not found,

39
00:03:03,000 --> 00:03:05,000
for the given input.

40
00:03:05,000 --> 00:03:10,000
And to this constructor this time I'm not going to pass a one parameter.

41
00:03:10,000 --> 00:03:17,000
I'm going to pass multiple parameters to throw a detail exception to my end user or to the client application.

42
00:03:17,000 --> 00:03:23,000
The three fields are going to be what is the resource name like, whether it is accounts or customer

43
00:03:23,000 --> 00:03:26,000
and what is the field name and what is the field value?

44
00:03:26,000 --> 00:03:26,000
The field name,

45
00:03:26,000 --> 00:03:32,000
Obviously we are trying to fetch based upon the mobile number, so it will throw a detail message to

46
00:03:32,000 --> 00:03:37,000
the end user or client application that you are trying to fetch account details based upon your mobile

47
00:03:37,000 --> 00:03:39,000
number with so and so value,

48
00:03:39,000 --> 00:03:40,000
And we are not able to find that.

49
00:03:40,000 --> 00:03:45,000
That's how we are going to throw an message to the client application.

50
00:03:45,000 --> 00:03:47,000
Now we have a problem here.

51
00:03:47,000 --> 00:03:50,000
The problem is this runtime exception constructor.

52
00:03:50,000 --> 00:03:54,000
It is going to accept only a single string as an input parameter.

53
00:03:54,000 --> 00:04:00,000
So what we have to do is we need to prepare a single string value based upon these three input fields

54
00:04:00,000 --> 00:04:03,000
from the ResourceNotFound exception constructor.

55
00:04:03,000 --> 00:04:09,000
For the same, I'm going to use a string.format() method using this string.format() method.

56
00:04:09,000 --> 00:04:11,000
I'm passing these three strings.

57
00:04:11,000 --> 00:04:16,000
These three strings will be replaced wherever I have mentioned these 

58
00:04:17,000 --> 00:04:17,000
%s.

59
00:04:17,000 --> 00:04:21,000
So, so and so resource not found with the given input data field name.

60
00:04:21,000 --> 00:04:23,000
And what is the field value?

61
00:04:23,000 --> 00:04:25,000
So with this we should be good with these exception.

62
00:04:25,000 --> 00:04:32,000
As a next step, we need to go to the global exception handler and we need to make sure we are writing

63
00:04:32,000 --> 00:04:36,000
a method very similar to these handle customer already exist.

64
00:04:36,000 --> 00:04:39,000
Exception So let me copy this method and paste it.

65
00:04:39,000 --> 00:04:42,000
So now we have two methods with the same name.

66
00:04:42,000 --> 00:04:44,000
Let's try to fix this compilation error.

67
00:04:44,000 --> 00:04:50,000
So the very first method I'm trying to change to a new method name which is handle resource,

68
00:04:50,000 --> 00:04:51,000
ResourseNotFound exception.

69
00:04:51,000 --> 00:04:57,000
And this method is going to handle the exception which is ResourceNotFound exception.

70
00:04:57,000 --> 00:05:00,000
So here the logic is going to be the same, but instead of,

71
00:05:00,000 --> 00:05:06,000
bad requests we need to send Not_Found the same I want to send as part of the response entity status

72
00:05:06,000 --> 00:05:07,000
as well.

73
00:05:07,000 --> 00:05:10,000
So with this we are good from an exception handling perspective.

74
00:05:10,000 --> 00:05:13,000
Now let's go to the AccountServiceImpl.

75
00:05:13,000 --> 00:05:18,000
So here we need to write the logic to fetch the account details and customer details based upon the

76
00:05:18,000 --> 00:05:19,000
mobile number.

77
00:05:19,000 --> 00:05:25,000
So I'm going to write a code here first, with the help of customerRepository, I'm trying to invoke

78
00:05:25,000 --> 00:05:27,000
a method findByMobileNumber().

79
00:05:27,000 --> 00:05:31,000
And to this method I'm going to pass the received mobile number.

80
00:05:31,000 --> 00:05:38,000
And if there is no record with the given mobile number, I'm going to invoke orElseThrow() method because

81
00:05:38,000 --> 00:05:43,000
this find by mobile number is going to return a optional of customer inside optional.

82
00:05:43,000 --> 00:05:51,000
We have a method called orElseThrow() using which we can throw an exception if there is no record present

83
00:05:51,000 --> 00:05:52,000
inside the optional.

84
00:05:52,000 --> 00:05:58,000
So here I'm going to write a lambda expression which is not going to accept any input parameter, but

85
00:05:58,000 --> 00:06:04,000
I'm simply going to throw an error which is new 
ResourceNotFound exception.

86
00:06:04,000 --> 00:06:08,000
And to this constructor I'm going to pass three parameters.

87
00:06:08,000 --> 00:06:11,000
The very first one is what is the resource that I'm not able to find?

88
00:06:11,000 --> 00:06:16,000
Customer is a resource because with a given mobile number we are not able to find the customer.

89
00:06:16,000 --> 00:06:22,000
And the second param value I'm going to mention as mobile number because using mobile number only,

90
00:06:22,000 --> 00:06:24,000
I'm not able to fetch the resource.

91
00:06:24,000 --> 00:06:27,000
And the third parameter obviously what is a mobile number value.

92
00:06:27,000 --> 00:06:34,000
So with this I should be able to throw an exception whenever there is no customer available with a given

93
00:06:34,000 --> 00:06:35,000
mobile number.

94
00:06:35,000 --> 00:06:42,000
But if there is a customer available, I need to make sure I'm catching that customer, into a variable

95
00:06:42,000 --> 00:06:43,000
called customer.

96
00:06:43,000 --> 00:06:45,000
So now I'm good with this.

97
00:06:45,000 --> 00:06:51,000
I'm able to fetch the customer details post that using the very similar logic, I need to make sure

98
00:06:51,000 --> 00:06:53,000
I'm fetching the account details as well.

99
00:06:53,000 --> 00:06:58,000
Because whenever someone is trying to invoke my rest API, they need all the details.

100
00:06:58,000 --> 00:06:59,000
Like what is the customer details?

101
00:06:59,000 --> 00:07:02,000
What is the account details that got created?

102
00:07:02,000 --> 00:07:07,000
So first, instead of customerRepository, I need to make sure I'm using accountRepository.

103
00:07:07,000 --> 00:07:14,000
Now inside my accounts table there is no mobile number using which I can query and at the same time

104
00:07:14,000 --> 00:07:22,000
I cannot invoke findByID() method because inside my accounts entity the primary key value is account

105
00:07:22,000 --> 00:07:22,000
number.

106
00:07:22,000 --> 00:07:26,000
But I received only mobile number from my client application.

107
00:07:26,000 --> 00:07:28,000
So what should I do here?

108
00:07:28,000 --> 00:07:35,000
I need to create a new method inside accountsRepository just like we created find by mobile number

109
00:07:35,000 --> 00:07:37,000
inside customerRepository.

110
00:07:37,000 --> 00:07:40,000
So let me go to the AccountsRepository here.

111
00:07:40,000 --> 00:07:42,000
I'm going to create a new method.

112
00:07:42,000 --> 00:07:48,000
The method is findByCustomerId(), So based upon the customer ID, it is going to fetch the account

113
00:07:48,000 --> 00:07:48,000
details.

114
00:07:48,000 --> 00:07:51,000
And here you may have a question like how do we know the customer ID?

115
00:07:51,000 --> 00:07:54,000
Because we didn't receive from the input request.

116
00:07:54,000 --> 00:07:59,000
That's where we will use the customer object that we fetched from the database based upon the mobile

117
00:07:59,000 --> 00:08:03,000
number to identify what is the customer ID for a given mobile number.

118
00:08:03,000 --> 00:08:07,000
So first I need to make sure I'm invoking 
findByCustomerId().

119
00:08:07,000 --> 00:08:13,000
Once I invoke this, findByCustomerId(), let me replace this customer to account so that I can resolve

120
00:08:13,000 --> 00:08:15,000
the compilation error that I have here.

121
00:08:15,000 --> 00:08:18,000
The variable name is going to be accounts.

122
00:08:18,000 --> 00:08:25,000
Now, instead of this mobile number, I'm going to pass customer.getCustomerId from thisCcustomer

123
00:08:25,000 --> 00:08:25,000
object.

124
00:08:25,000 --> 00:08:27,000
The same logic we are going to follow.

125
00:08:27,000 --> 00:08:32,000
If there is no account with the given customer ID, we are going to throw ResourceNotFound exception,

126
00:08:32,000 --> 00:08:39,000
but instead of customer here we need to mention account because we are not able to identify account

127
00:08:39,000 --> 00:08:48,000
resource for a given customer ID and the value is going to be customer.getCustomerId().toString().

128
00:08:48,000 --> 00:08:52,000
Of course there won't be any scenario in our application if there is a customer exist, definitely there

129
00:08:52,000 --> 00:08:55,000
will be also an account resource will be available.

130
00:08:55,000 --> 00:08:59,000
But this just an in case someone messed up with the data.

131
00:08:59,000 --> 00:09:03,000
Then just a rare scenario that we are trying to handle here.

132
00:09:03,000 --> 00:09:06,000
Now we have customer, entity and accounts entity.

133
00:09:06,000 --> 00:09:09,000
Can we send this directly to the client?

134
00:09:09,000 --> 00:09:14,000
Of course not, because these entities, they have a lot of sensitive information and metadata information

135
00:09:14,000 --> 00:09:20,000
like createdat created by at the same time customer ID, which is unnecessary for my client application.

136
00:09:20,000 --> 00:09:22,000
They only want useful information.

137
00:09:22,000 --> 00:09:27,000
That's why we need to convert these entities into the Dto classes.

138
00:09:27,000 --> 00:09:34,000
But as of now we have these CustomerDto and 
AccountsDto as two separate classes like accountsDto

139
00:09:34,000 --> 00:09:40,000
holds strictly the data related to accounts, and similarly, customer data holds the data related

140
00:09:40,000 --> 00:09:46,000
to customer only if you want to send the combined information or aggregated information of both CustomerDto

141
00:09:46,000 --> 00:09:47,000
and AccountsDto

142
00:09:47,000 --> 00:09:49,000
We have two options.

143
00:09:49,000 --> 00:09:57,000
Either we can create one more Dto class where we can try to refer both these Dto classes are inside these CustomerDto

144
00:09:57,000 --> 00:10:00,000
or we can create one more field,

145
00:10:00,000 --> 00:10:04,000
Of type AccountsDto and with the field name as 
AccountsDto.

146
00:10:04,000 --> 00:10:08,000
So this way also we can achieve the Dto pattern.

147
00:10:08,000 --> 00:10:14,000
So I'm going to follow this approach, but if you want, you can also create separate Dto class.

148
00:10:14,000 --> 00:10:19,000
But I would recommend that approach only if your Dto has lot number of fields and they are very big

149
00:10:19,000 --> 00:10:20,000
in nature.

150
00:10:20,000 --> 00:10:23,000
But for these smaller application this should be fine.

151
00:10:23,000 --> 00:10:29,000
I'll go to the AccountServiceImpl and here first, with the help of CustomerMapper, I'm going to invoke

152
00:10:29,000 --> 00:10:36,000
mapToCustomerDto() and to this method we need to pass what is the customer along with the new object

153
00:10:36,000 --> 00:10:38,000
of customerDto?

154
00:10:38,000 --> 00:10:38,000
The same

155
00:10:38,000 --> 00:10:44,000
I'm going to catch into a variable of type customerDto for this.

156
00:10:44,000 --> 00:10:46,000
I can go to the next line here.

157
00:10:46,000 --> 00:10:52,000
I'm going to invoke customerDto.setAccountsDto and to this setter method.

158
00:10:52,000 --> 00:10:55,000
I need to pass the Dto of my accounts entity.

159
00:10:55,000 --> 00:11:01,000
So let me invoke the AccountsMapper here and using this AccountsMapper, I'm going to invoke map two

160
00:11:01,000 --> 00:11:07,000
accounts and I'm going to pass accounts to new, AccountsDto.

161
00:11:07,000 --> 00:11:12,000
So with this we should be good and I'm going to return this customerDto from this method.

162
00:11:12,000 --> 00:11:15,000
So now let me go to the controller layer.

163
00:11:15,000 --> 00:11:16,000
Inside my controller layer.

164
00:11:16,000 --> 00:11:23,000
I'm going to write business logic here to invoke my 
IAccountService and the method fetchAccount().

165
00:11:23,000 --> 00:11:26,000
And to this method I'm going to pass the mobile number.

166
00:11:26,000 --> 00:11:30,000
And from this method we are going to get the customerDto.

167
00:11:30,000 --> 00:11:36,000
So let me try to catch the same here on the left hand side with the help of this CustomerDto object.

168
00:11:36,000 --> 00:11:42,000
Once I have this CustomerDto object, I can try to write a return statement with the help of 

169
00:11:42,000 --> 00:11:49,000
ResponseEntity.status and the status is going to be

170
00:11:49,000 --> 00:11:49,000
HttpStatus.OK.

171
00:11:49,000 --> 00:11:50,000
Okay

172
00:11:50,000 --> 00:11:54,000
means the operation is successful and I'm sending the data to you.

173
00:11:54,000 --> 00:11:59,000
So with the help of body() method, I'm invoking and passing the object of the CustomerDto.

174
00:11:59,000 --> 00:12:02,000
So with this, our method is ready right now.

175
00:12:02,000 --> 00:12:06,000
So let me save this changes and do a build.

176
00:12:06,000 --> 00:12:09,000
Once the build is completed, my server will be restarting.

177
00:12:09,000 --> 00:12:15,000
Like I said before, whenever my server is restarting, my data will be lost inside the h2database.

178
00:12:15,000 --> 00:12:17,000
We can also try to validate the same.

179
00:12:17,000 --> 00:12:19,000
So I'm trying to refresh the page here.

180
00:12:19,000 --> 00:12:20,000
So let me connect again.

181
00:12:20,000 --> 00:12:23,000
I'm trying to search for accounts so you can see the data.

182
00:12:23,000 --> 00:12:24,000
Everything is wiped off.

183
00:12:24,000 --> 00:12:30,000
So what we can do is this is a temporary problem that we are going to face till we migrate to the MySQL

184
00:12:30,000 --> 00:12:31,000
database in the coming sections.

185
00:12:31,000 --> 00:12:34,000
As a workaround, I'm going to invoke this create API.

186
00:12:34,000 --> 00:12:37,000
Again, the account is created successfully.

187
00:12:37,000 --> 00:12:39,000
Now I'll take this mobile number.

188
00:12:39,000 --> 00:12:46,000
I'm going to open this fetch account details request and here I need to invoke localhost8080api/fetch

189
00:12:46,000 --> 00:12:50,000
and mobile number is a query param that we need to pass.

190
00:12:50,000 --> 00:12:52,000
That's why there is a question mark.

191
00:12:52,000 --> 00:12:54,000
What is the query param name, mobile number.

192
00:12:54,000 --> 00:12:58,000
And to this query param I'm going to pass the value of my mobile number.

193
00:12:58,000 --> 00:13:04,000
Please make sure this name is matching with whatever you have mentioned here as a request param.

194
00:13:04,000 --> 00:13:11,000
So now I'm going to click on this Send button and like you can see here, I got a response saying that

195
00:13:11,000 --> 00:13:15,000
that this is the name of the customer, this is the email, this is the mobile number.

196
00:13:15,000 --> 00:13:22,000
And inside this customer details there is an embedded object with the name account and it has details

197
00:13:22,000 --> 00:13:24,000
like account number, account type and branch address.

198
00:13:24,000 --> 00:13:31,000
Now if I try to invoke the same API with a mobile number that does not exist inside my database, I

199
00:13:31,000 --> 00:13:32,000
should get an exception.

200
00:13:32,000 --> 00:13:36,000
I'm getting an exception, but it is not coming the way that I design.

201
00:13:36,000 --> 00:13:38,000
So there is an issue in our code.

202
00:13:38,000 --> 00:13:40,000
Let me check the same,here

203
00:13:40,000 --> 00:13:41,000
we made a mistake.

204
00:13:41,000 --> 00:13:47,000
Like when we build this handle ResourceNotFound exception, we are accepting a customer already exist

205
00:13:47,000 --> 00:13:50,000
exception instead of ResourceNotFound exception.

206
00:13:50,000 --> 00:13:52,000
So let me correct this issue.

207
00:13:52,000 --> 00:13:54,000
Please ignore my mistake here.

208
00:13:54,000 --> 00:13:55,000
Let me do a build.

209
00:13:55,000 --> 00:13:59,000
Sometimes these issues happen regardless how experienced you are.

210
00:13:59,000 --> 00:14:01,000
This kind of small mistakes will always happen.

211
00:14:01,000 --> 00:14:06,000
That's why debugging and unit testing is very important inside any project.

212
00:14:06,000 --> 00:14:10,000
So since I'm doing unit testing, I'm able to identify this issue.

213
00:14:10,000 --> 00:14:15,000
Now, my server might have restarted, but regardless, I can still test this API because we are trying

214
00:14:15,000 --> 00:14:17,000
to test the native scenario only here.

215
00:14:17,000 --> 00:14:22,000
So if I try to invoke here, you can see I'm getting a proper response saying that this is the error

216
00:14:22,000 --> 00:14:27,000
code, this is the error message saying that customer not found with the given input data mobile number.

217
00:14:27,000 --> 00:14:31,000
And this is a mobile number that I sent in the request with this.

218
00:14:31,000 --> 00:14:36,000
I'm assuming your super, super clear about the fetch operation that we have implemented inside 

219
00:14:36,000 --> 00:14:37,000
AccountsService.

220
00:14:37,000 --> 00:14:43,000
So please validate your changes inside your local by comparing with the code that you have inside the

221
00:14:43,000 --> 00:14:44,000
GitHub repo.

222
00:14:44,000 --> 00:14:50,000
I'm assuming you're following me and you're having a lot of fun and you're learning a lot of new things

223
00:14:50,000 --> 00:14:51,000
here inside this course.

224
00:14:51,000 --> 00:14:52,000
Thank you.

225
00:14:52,000 --> 00:14:54,000
And I'll catch you in the next lecture bye.


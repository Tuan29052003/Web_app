1
00:00:00,000 --> 00:00:06,000
In the previous lecture, we discussed very quickly about client credentials grant type flow available

2
00:00:06,000 --> 00:00:08,000
inside the Oauth2 framework.

3
00:00:08,000 --> 00:00:14,000
Now using the same grant type flow, I'm going to explain you how we are going to secure our Gateway

4
00:00:14,000 --> 00:00:20,000
server, which is acting as an edge server for our microservices. Like you can see here,

5
00:00:20,000 --> 00:00:27,000
so first we are going to have some client application so this client application can be some external

6
00:00:27,000 --> 00:00:31,000
service or some external API or some external backend server.

7
00:00:31,000 --> 00:00:35,000
So they are trying to communicate with our microservice network.

8
00:00:35,000 --> 00:00:37,000
So this is the client application.

9
00:00:37,000 --> 00:00:43,000
As a next step, we are going to have the auth server which we are going to set up with the help of key

10
00:00:43,000 --> 00:00:47,000
clock inside the Easy Bank microservices network.

11
00:00:47,000 --> 00:00:52,000
In the very first step, like you can see, the client is going to connect with the auth server, with

12
00:00:52,000 --> 00:00:56,000
the client credentials and get a access token.

13
00:00:56,000 --> 00:01:03,000
So whatever external service or external API client who want to connect with my microservices behind

14
00:01:03,000 --> 00:01:08,000
the scenes, they need to work with the admins of the key clock to register themselves as a valid client

15
00:01:08,000 --> 00:01:14,000
application. Because the keyclock should not give access tokens for all type of external clients.

16
00:01:14,000 --> 00:01:22,000
Only approved external client applications by my key clock admin or by my business leaders

17
00:01:22,000 --> 00:01:27,000
only those applications should be able to communicate with my auth server and with the gateway server.

18
00:01:27,000 --> 00:01:34,000
So think like this client application is a valid client, so the client credentials are valid as a response

19
00:01:34,000 --> 00:01:35,000
to this request

20
00:01:35,000 --> 00:01:39,000
inside the step one, the keyclock is going to issue an access token.

21
00:01:39,000 --> 00:01:41,000
Using the same access token

22
00:01:41,000 --> 00:01:47,000
the client application is going to invoke a path available inside the edge server along with the access

23
00:01:47,000 --> 00:01:49,000
token issued by the auth server.

24
00:01:49,000 --> 00:01:53,000
So here you can see the Edge server or the gateway server.

25
00:01:53,000 --> 00:01:55,000
We are going to make it as a resource server.

26
00:01:55,000 --> 00:01:57,000
So what is the role of resource server?

27
00:01:57,000 --> 00:02:04,000
The resource server should not respond to the clients who are sending the requests without a valid access

28
00:02:04,000 --> 00:02:04,000
token.

29
00:02:04,000 --> 00:02:10,000
So this way we are securing our gateway server so that only authenticated client applications.

30
00:02:10,000 --> 00:02:12,000
They can invoke our edge server.

31
00:02:12,000 --> 00:02:19,000
Once my edge server receives the access token, it is going to validate the same access token with the

32
00:02:19,000 --> 00:02:20,000
auth server. Behind the scenes

33
00:02:20,000 --> 00:02:23,000
it is going to check with the auth server saying that.

34
00:02:23,000 --> 00:02:25,000
Did you issue this access token?

35
00:02:25,000 --> 00:02:26,000
Is this a valid access token?

36
00:02:26,000 --> 00:02:32,000
Once the keyclock or the auth server confirms saying that this access token is valid back to the gateway

37
00:02:32,000 --> 00:02:38,000
server, the gateway server at the Edge server is going to forward the request that it received from

38
00:02:38,000 --> 00:02:45,000
the client application to the individual microservices like accounts, loans and cards microservice.

39
00:02:45,000 --> 00:02:51,000
So here you may have a very good question, which is we are not protecting our individual microservices

40
00:02:51,000 --> 00:02:53,000
like accounts, loans and cards.

41
00:02:53,000 --> 00:02:59,000
So what is stopping my external client application to directly invoke accounts microservice, loans

42
00:02:59,000 --> 00:03:01,000
microservice and cards microservice.

43
00:03:01,000 --> 00:03:05,000
There can be some hacker or they can be some rogue client application.

44
00:03:05,000 --> 00:03:12,000
They can easily skip this process and they can directly try to communicate with the individual microservices.

45
00:03:12,000 --> 00:03:13,000
So that's a very good question.

46
00:03:13,000 --> 00:03:15,000
So let me try to answer the same.

47
00:03:15,000 --> 00:03:20,000
Whenever we are trying to deploy our accounts, microservice, our loans, our cards, microservice

48
00:03:20,000 --> 00:03:26,000
in the higher environments with the help of Docker compose or with the help of Kubernetes, we can make

49
00:03:26,000 --> 00:03:33,000
these microservices deployed behind a firewall or behind a Docker network so that any external client

50
00:03:33,000 --> 00:03:39,000
application they cannot communicate directly only the component which is deployed inside the same

51
00:03:39,000 --> 00:03:44,000
firewall or which is deployed inside the same Docker network can communicate with these services.

52
00:03:44,000 --> 00:03:49,000
So what is that component which we are going to deploy inside the same firewall or inside the same network?

53
00:03:50,000 --> 00:03:56,000
It is the gateway server and with that the client applications is not going to have any option except

54
00:03:56,000 --> 00:03:58,000
to forwarding the request to the gateway server.

55
00:03:58,000 --> 00:04:02,000
They can never be able to directly invoke the individual microservice.

56
00:04:02,000 --> 00:04:09,000
So I hope you are clear, but if you are thinking like why not make our individual microservices also

57
00:04:09,000 --> 00:04:15,000
to be as a resource server, then let me stop you there because it's a very valid assumption, but we

58
00:04:15,000 --> 00:04:16,000
should not make them resource server.

59
00:04:17,000 --> 00:04:22,000
The reason is if you make all your internal microservices also resource server, you will unnecessarily

60
00:04:22,000 --> 00:04:24,000
complicate things.

61
00:04:24,000 --> 00:04:30,000
And on top of that the performance of all your microservices will be impacted. Because whenever you make

62
00:04:30,000 --> 00:04:35,000
your individual microservices as a resource server, every time they are going to expect the access

63
00:04:35,000 --> 00:04:41,000
token for each and every request, even for the internal communication that is happening within your

64
00:04:41,000 --> 00:04:42,000
organization network.

65
00:04:42,000 --> 00:04:47,000
And whenever the access token is involved, the individual microservices they have to validate the

66
00:04:47,000 --> 00:04:50,000
same with the keyclock or the auth server.

67
00:04:50,000 --> 00:04:54,000
So this will unnecessarily bring a lot of complexities and performance issues.

68
00:04:54,000 --> 00:04:59,000
But I'm not saying we should not make our internal communication between

69
00:04:59,000 --> 00:05:02,000
the microservices to be completely unsecure.

70
00:05:02,000 --> 00:05:08,000
There are other, better industry standards and approaches which I will try to explain when we are trying

71
00:05:08,000 --> 00:05:13,000
to deploy our microservices into Kubernetes cluster.

72
00:05:13,000 --> 00:05:15,000
I hope you are clear with this discussion.

73
00:05:15,000 --> 00:05:20,000
Like I highlighted, we need to use these client credentials grant type flow only in the scenarios

74
00:05:20,000 --> 00:05:25,000
where two different backend applications or two different APIs are trying to communicate with each

75
00:05:25,000 --> 00:05:26,000
other.

76
00:05:26,000 --> 00:05:29,000
So there is an API which I hosted inside my gateway server.

77
00:05:29,000 --> 00:05:35,000
So some other API are some other backend service or some other external service application.

78
00:05:35,000 --> 00:05:40,000
They're trying to invoke my API. Since there is no end user involved, since there is no application

79
00:05:40,000 --> 00:05:45,000
involved, this is the perfect grant flow that we can use inside this scenario.

80
00:05:45,000 --> 00:05:46,000
I hope this is clear.

81
00:05:46,000 --> 00:05:50,000
Now let me try to explain the same steps in a more funny way.

82
00:05:50,000 --> 00:05:57,000
Like we know inside our drama we are going to have three actors, client, resource server and auth server.

83
00:05:57,000 --> 00:06:00,000
They're sitting idle, they're enjoying their holidays.

84
00:06:00,000 --> 00:06:01,000
Now to my client application

85
00:06:01,000 --> 00:06:08,000
someone gave a work saying that go ahead and invoke the APIs available inside the Easy Bank microservices

86
00:06:08,000 --> 00:06:14,000
network and get me some account details or get me some card details or loan details. With that

87
00:06:14,000 --> 00:06:19,000
the holidays for the client application completed. Now immediately client application will go ahead and

88
00:06:19,000 --> 00:06:24,000
ask the resource server saying that I'm trying to invoke so and so API,

89
00:06:24,000 --> 00:06:26,000
please give me the response.

90
00:06:26,000 --> 00:06:29,000
You can see inside this step there is no authentication, there is no access token.

91
00:06:30,000 --> 00:06:33,000
Seems this guy are this client is new to the oauth2 flow.

92
00:06:33,000 --> 00:06:37,000
The resource server at the Gateway server is going to respond.

93
00:06:37,000 --> 00:06:40,000
Sorry buddy, I can only process the request,

94
00:06:40,000 --> 00:06:43,000
who provides an access token from the auth server.

95
00:06:43,000 --> 00:06:46,000
So go ahead and get an access token from the auth server.

96
00:06:46,000 --> 00:06:52,000
Now my client application, which is a lazy application, again trying to complain within itself, saying

97
00:06:52,000 --> 00:06:56,000
that now I should send the request again to different server.

98
00:06:56,000 --> 00:06:59,000
Oh, seems a pretty bad day for me.

99
00:06:59,000 --> 00:07:01,000
So that's what it is thinking. As a next step,

100
00:07:01,000 --> 00:07:07,000
it has to send the request to the auth server saying that Hey auth server, please give me the access token

101
00:07:07,000 --> 00:07:10,000
and the auth server is going to respond.

102
00:07:10,000 --> 00:07:12,000
I can't give you access token just like that.

103
00:07:12,000 --> 00:07:14,000
I don't know who you are.

104
00:07:14,000 --> 00:07:19,000
In order to get an access token from me, you need to register with me and the same needs to be approved

105
00:07:19,000 --> 00:07:20,000
by my admin.

106
00:07:20,000 --> 00:07:23,000
So the client don't know all the story.

107
00:07:23,000 --> 00:07:29,000
So behind the scenes what it will do is it will take enough approvals and it will complete the registration

108
00:07:29,000 --> 00:07:30,000
process with the Keycloak server.

109
00:07:30,000 --> 00:07:37,000
Once this registration process is completed as a next step, the client application this time is going

110
00:07:37,000 --> 00:07:42,000
to invoke the auth server again saying that please give me an access token,

111
00:07:42,000 --> 00:07:45,000
this time I have a valid clientId, client secret.

112
00:07:45,000 --> 00:07:49,000
Please take this and give me an access token.

113
00:07:49,000 --> 00:07:53,000
So now my ad server will say Don't get too much excited.

114
00:07:53,000 --> 00:07:56,000
I'm going to show lot many access tokens to many clients.

115
00:07:56,000 --> 00:07:58,000
Seems you are pretty excited about this.

116
00:07:58,000 --> 00:07:59,000
This is very normal to me.

117
00:07:59,000 --> 00:08:05,000
So after saying this, the kick lock is going to validate the client credentials and it is going to

118
00:08:05,000 --> 00:08:07,000
respond back with the access token.

119
00:08:07,000 --> 00:08:13,000
If the key clock supports OpenID also in such scenarios, along with the access Token, the client also

120
00:08:13,000 --> 00:08:16,000
going to get the ID token as well.

121
00:08:16,000 --> 00:08:22,000
So in the step six, the ad server is going to say, Congratulations buddy, you got an access token

122
00:08:22,000 --> 00:08:23,000
here, your access token,

123
00:08:23,000 --> 00:08:24,000
all the best.

124
00:08:24,000 --> 00:08:31,000
With that, the client application feels very happy and it feels like it accomplished something.

125
00:08:31,000 --> 00:08:32,000
But the story not ended there.

126
00:08:32,000 --> 00:08:34,000
It has only just access token.

127
00:08:34,000 --> 00:08:35,000
It didn't get . It

128
00:08:35,000 --> 00:08:42,000
don't have actual resources staying inside the easy bank network. So soon it will realize this and it

129
00:08:42,000 --> 00:08:48,000
is going to forward the request to the resource server this time along with the request,

130
00:08:48,000 --> 00:08:50,000
it is also going to send the access token.

131
00:08:50,000 --> 00:08:56,000
Now as a next step, my resource server are my spring cloud Gateway is going to validate the same access

132
00:08:56,000 --> 00:08:58,000
token with the auth server.

133
00:08:58,000 --> 00:09:02,000
So the Spring Cloud Gateway says, I can't believe this client application.

134
00:09:02,000 --> 00:09:07,000
Last time also this guy came to me and asked me to send the response without any access token.

135
00:09:07,000 --> 00:09:12,000
This time, I'm not sure if this guy came with a valid access token or he's trying to bluff me with

136
00:09:12,000 --> 00:09:14,000
some random access token.

137
00:09:14,000 --> 00:09:17,000
The gateway gossiped all this into the Keycloak auth server.

138
00:09:17,000 --> 00:09:22,000
Now my keyclock auth server says, don't worry, I'm going to validate this for you.

139
00:09:22,000 --> 00:09:28,000
And once the validation is completed, the ad server confirm back to the gateway saying that, since this

140
00:09:28,000 --> 00:09:32,000
guy is valid, please go ahead and process his request and respond the same to him.

141
00:09:32,000 --> 00:09:39,000
So now my spring cloud gateway is going to forward the request to the individual microservices like

142
00:09:39,000 --> 00:09:40,000
accounts, cards and loans.

143
00:09:40,000 --> 00:09:46,000
And once the response is received from the individual microservices, it is going to forward the same

144
00:09:46,000 --> 00:09:48,000
back to the client application.

145
00:09:48,000 --> 00:09:51,000
And with this, the story ended happily.

146
00:09:51,000 --> 00:09:55,000
Now the client application received the response from the gateway

147
00:09:55,000 --> 00:09:59,000
and with that now everyone can go back to the

148
00:09:59,000 --> 00:09:59,000
holiday mode.

149
00:09:59,000 --> 00:10:01,000
I hope this is clear.

150
00:10:01,000 --> 00:10:03,000
Now, I know this is completely theory.

151
00:10:03,000 --> 00:10:08,000
You may have lot many questions like how we are going to convert our spring cloud gateway as a resource

152
00:10:08,000 --> 00:10:13,000
server, how we are going to set up the auth server with the help of key clock, how we are going to

153
00:10:13,000 --> 00:10:16,000
register the client application inside the auth server.

154
00:10:16,000 --> 00:10:18,000
So I know you may have many questions.

155
00:10:18,000 --> 00:10:20,000
Don't worry, I'm there for you.

156
00:10:20,000 --> 00:10:25,000
I'm going to guide at each and every step and in the same process all these things that we have discussed

157
00:10:25,000 --> 00:10:27,000
will be more clear for you.

158
00:10:27,000 --> 00:10:28,000
Thank you.

159
00:10:28,000 --> 00:10:30,000
And I'll catch you in the next lecture bye.


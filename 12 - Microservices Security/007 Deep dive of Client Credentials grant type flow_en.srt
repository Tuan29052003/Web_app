1
00:00:00,000 --> 00:00:06,000
Now is the time to deep dive into the Oauth2 framework. Just by knowing the definition of Oauth2 and

2
00:00:06,000 --> 00:00:07,000
OpenID Connect.

3
00:00:07,000 --> 00:00:11,000
You cannot implement security inside our microservices network.

4
00:00:11,000 --> 00:00:18,000
We need to deep dive into these standards and learn the applicable grant type flows for our microservices

5
00:00:18,000 --> 00:00:19,000
network.

6
00:00:19,000 --> 00:00:25,000
Inside this lecture, we are going to discuss about client credentials grant type flow available inside

7
00:00:25,000 --> 00:00:27,000
the Oauth2 framework.

8
00:00:27,000 --> 00:00:35,000
Like I said before, Oauth2 has various grant type flows that we can use in implementing security inside

9
00:00:35,000 --> 00:00:39,000
our web applications based upon the type of communication.

10
00:00:39,000 --> 00:00:44,000
So before I try to explain more details about these client credentials grant type flow, first let

11
00:00:44,000 --> 00:00:49,000
me give clarification under which scenarios we need to use this grant type flow.

12
00:00:49,000 --> 00:00:51,000
We need to use this grant type flow.

13
00:00:51,000 --> 00:00:58,000
When two APIs are when two different backend servers, they are trying to communicate with each other.

14
00:00:58,000 --> 00:01:04,000
So in this communication, if you want to enforce security, then this is the perfect grant flow that

15
00:01:04,000 --> 00:01:05,000
we can use.

16
00:01:05,000 --> 00:01:11,000
So here there will be three actors or three roles or three jargons will be involved inside this flow.

17
00:01:11,000 --> 00:01:15,000
The very first and important component is auth server.

18
00:01:15,000 --> 00:01:21,000
This arch server is responsible to authenticate the client application and issue the access token.

19
00:01:21,000 --> 00:01:26,000
So how we are going to build this auth server like we discussed, we are going to leverage Keycloak

20
00:01:26,000 --> 00:01:30,000
to set up the auth server inside our Microservice network.

21
00:01:30,000 --> 00:01:32,000
Now coming to the resource server,

22
00:01:32,000 --> 00:01:33,000
so what is this resource server?

23
00:01:33,000 --> 00:01:40,000
We'll make our gateway server as a resource server so that anyone who wants to communicate with our

24
00:01:40,000 --> 00:01:45,000
gateway server, which is acting as a edge server for our microservice, they need to make sure they

25
00:01:45,000 --> 00:01:49,000
are authenticated with the ad server and post authentication

26
00:01:49,000 --> 00:01:50,000
with auth server

27
00:01:50,000 --> 00:01:54,000
they should get an access token from the auth server and the same it has to be sent to the resource

28
00:01:54,000 --> 00:01:55,000
server.

29
00:01:55,000 --> 00:02:01,000
The resource server are the gateway server is going to send the response only if it receives the proper

30
00:02:01,000 --> 00:02:06,000
access token from the client application that is issued by the auth server.

31
00:02:06,000 --> 00:02:12,000
With that quick introduction, let me show you a sample flow how these client credentials grant type

32
00:02:12,000 --> 00:02:13,000
flow is going to work.

33
00:02:13,000 --> 00:02:20,000
In the very first step, the client application is going to ask auth server that I want to access a

34
00:02:20,000 --> 00:02:25,000
protected resource available inside the resource server, but my resource server is not going to respond

35
00:02:25,000 --> 00:02:28,000
me because it expects access token from me.

36
00:02:28,000 --> 00:02:28,000
That's why

37
00:02:28,000 --> 00:02:31,000
please issue me an access token.

38
00:02:31,000 --> 00:02:37,000
So the client is going to request the auth server to issue an access token and in the same process the

39
00:02:37,000 --> 00:02:40,000
client application should prove its identity. For the same,

40
00:02:40,000 --> 00:02:46,000
it is going to send the client credentials to the auth server saying that this is my client ID and this

41
00:02:46,000 --> 00:02:47,000
is my client secret.

42
00:02:47,000 --> 00:02:52,000
And here please note that the client application is some other back end application or

43
00:02:52,000 --> 00:02:59,000
some other API or some other external microservice, who is trying to invoke our resource server.

44
00:02:59,000 --> 00:03:04,000
So that's why it is also going to highlight there is no end user involved, there is no UI application

45
00:03:04,000 --> 00:03:05,000
involved.

46
00:03:05,000 --> 00:03:12,000
That's what it is trying to convey in the very first step. Once my auth server receives the request and

47
00:03:12,000 --> 00:03:18,000
once it validated the credentials provided by the client application, it is going to issue an access

48
00:03:18,000 --> 00:03:20,000
token to the client application.

49
00:03:20,000 --> 00:03:26,000
Once the access token is received by the client application, the client application is going to send

50
00:03:26,000 --> 00:03:29,000
the same access token to the resource server.

51
00:03:29,000 --> 00:03:30,000
Along with the access token

52
00:03:30,000 --> 00:03:33,000
it will also convey which resource it is trying to access.

53
00:03:33,000 --> 00:03:39,000
Now my resource server will take that access token and behind the scenes it will validate the access

54
00:03:39,000 --> 00:03:45,000
token with the auth server and if the client application has enough privileges to invoke that particular

55
00:03:45,000 --> 00:03:52,000
secure API or secure resource, then my resource server is going to respond to the client application.

56
00:03:52,000 --> 00:03:54,000
Your token is validated successfully.

57
00:03:54,000 --> 00:04:00,000
Here are the protected resources that you have requested, which means inside the step four, my resource

58
00:04:00,000 --> 00:04:06,000
server is going to send the response back to the client based upon the request that it sent.

59
00:04:06,000 --> 00:04:10,000
So in our scenario, the resource server is going to be gateway.

60
00:04:10,000 --> 00:04:16,000
So behind the scenes, if my client application is trying to create an account, the gate server will

61
00:04:16,000 --> 00:04:17,000
validate the access token

62
00:04:17,000 --> 00:04:24,000
and once the access token is validated and once it feels like the client application has enough privileges

63
00:04:24,000 --> 00:04:30,000
to create an account, then behind the scenes it is going to invoke other microservices that are available

64
00:04:30,000 --> 00:04:34,000
inside the microservice network like accounts Microservice.

65
00:04:34,000 --> 00:04:37,000
Once it receives the successful response from the accounts

66
00:04:37,000 --> 00:04:38,000
microservice the same response

67
00:04:38,000 --> 00:04:41,000
it is going to forward to the client application.

68
00:04:41,000 --> 00:04:45,000
I tried to mention more details about this flow in the next slide.

69
00:04:45,000 --> 00:04:46,000
Let me go to that.

70
00:04:46,000 --> 00:04:51,000
Like you can see here in the step one, whenever the client is making a request to the auth server for

71
00:04:51,000 --> 00:04:57,000
an access token, the client application has to provide what is a clientID, what is the client secret.

72
00:04:57,000 --> 00:04:59,000
So these are the credentials of the client

73
00:04:59,000 --> 00:05:05,000
application which it might have received during the registration process with the auth server and inside

74
00:05:05,000 --> 00:05:06,000
the same request.

75
00:05:06,000 --> 00:05:10,000
It should also mention what are the scope details that it is requesting.

76
00:05:10,000 --> 00:05:14,000
So these scopes, like we discussed, these are very similar to authorities.

77
00:05:14,000 --> 00:05:19,000
If my client application is looking for email details, then the scope is going to be email.

78
00:05:19,000 --> 00:05:25,000
So based upon my client application requirements, it is going to mention the corresponding scope inside

79
00:05:25,000 --> 00:05:26,000
the request.

80
00:05:26,000 --> 00:05:33,000
And this doesn't mean that whatever my client application is asking, the auth server is going to construct

81
00:05:33,000 --> 00:05:33,000
that scope.

82
00:05:33,000 --> 00:05:35,000
It is not going to work that way.

83
00:05:35,000 --> 00:05:41,000
While registering these clients with the auth server, the admin of the ad server like Keycloak server,

84
00:05:41,000 --> 00:05:45,000
they will make some configuration for this clientId

85
00:05:45,000 --> 00:05:52,000
I want to only allow this set of scopes. So when my client application is sending the scope, it has

86
00:05:52,000 --> 00:05:58,000
to make sure whatever it is sending inside the request, it has to match with the list of scopes inside

87
00:05:58,000 --> 00:05:59,000
the auth server.

88
00:05:59,000 --> 00:06:05,000
If it is trying to be smart and try to get some other scope which is not defined inside the auth server,

89
00:06:05,000 --> 00:06:09,000
then it is going to get an error as a response.

90
00:06:09,000 --> 00:06:10,000
So that's the details around scope.

91
00:06:10,000 --> 00:06:16,000
And apart from these clientId, client secret and scope inside the request, the client application

92
00:06:16,000 --> 00:06:18,000
should also send grant type.

93
00:06:18,000 --> 00:06:22,000
Inside this grant type it is going to mention the value as client credentials.

94
00:06:22,000 --> 00:06:24,000
With this we are telling to the auth server.

95
00:06:24,000 --> 00:06:29,000
The current grant flow that it needs to follow is client credentials grant type flow.

96
00:06:29,000 --> 00:06:35,000
So since there won't be any end user involved in this scenario, the ad server will not ask credentials

97
00:06:35,000 --> 00:06:37,000
of end user or resource owner.

98
00:06:37,000 --> 00:06:42,000
It will simply assume there is no resource owner inside this flow.

99
00:06:42,000 --> 00:06:48,000
So this is the most simplest grant type flow In Oauth2 we are going to discuss most complex grant flow

100
00:06:48,000 --> 00:06:50,000
also in the coming lectures.

101
00:06:50,000 --> 00:06:55,000
And the last important point, which is like I said, we need to use this authentication flow or grant

102
00:06:55,000 --> 00:07:01,000
type flow only if there is no end user and there is no UI application involved.

103
00:07:01,000 --> 00:07:07,000
This grant flow is strictly for the scenarios where two different applications are trying to communicate

104
00:07:07,000 --> 00:07:10,000
with each other using backend APIs.

105
00:07:10,000 --> 00:07:11,000
I hope you are clear.

106
00:07:11,000 --> 00:07:17,000
If something is not clear, don't worry, I'm going to explain the same grant type flow by taking our

107
00:07:17,000 --> 00:07:20,000
Easy Bank Microservices as an example.

108
00:07:20,000 --> 00:07:25,000
And at the same time, when we implement this grant type flow and see the demo inside our microservices

109
00:07:25,000 --> 00:07:28,000
network, then it is going to be super clear for you.

110
00:07:28,000 --> 00:07:32,000
But for now, please note that we should use this grant type flow only in the scenarios.

111
00:07:32,000 --> 00:07:39,000
When two backend APIs are two backend servers or two applications are trying to communicate with each

112
00:07:39,000 --> 00:07:39,000
other.

113
00:07:39,000 --> 00:07:42,000
Thank you and I'll catch you in the next lecture bye.


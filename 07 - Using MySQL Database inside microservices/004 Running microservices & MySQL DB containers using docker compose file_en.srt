1
00:00:00,000 --> 00:00:01,000
Inside this lecture,

2
00:00:01,000 --> 00:00:07,000
let's try to validate that Docker compose changes, but before we try to run the Docker Compose command,

3
00:00:07,000 --> 00:00:11,000
we missed one update inside our Docker compose file in the previous lecture.

4
00:00:11,000 --> 00:00:17,000
If you can scroll down the Docker image name for all the microservices should have a tag name which

5
00:00:17,000 --> 00:00:26,000
is S7. So please replace all the S6 Stacks names with S7, since we have new Docker images generated inside

6
00:00:26,000 --> 00:00:28,000
this section, we need to use them.

7
00:00:28,000 --> 00:00:35,000
If you use S6 related Docker images, they will have H2 database related changes and it is not going

8
00:00:35,000 --> 00:00:35,000
to work.

9
00:00:35,000 --> 00:00:38,000
That's why after making these changes, we should be good.

10
00:00:38,000 --> 00:00:40,000
Now let me go to the terminal.

11
00:00:40,000 --> 00:00:45,000
Inside my terminal I'm going to navigate to the Docker compose folder.

12
00:00:45,000 --> 00:00:51,000
So inside this Docker compose we have default folder and inside this folder only we have made all the

13
00:00:51,000 --> 00:00:52,000
changes.

14
00:00:52,000 --> 00:00:56,000
So the command that we need to run here is docker compose up.

15
00:00:56,000 --> 00:00:59,000
So I'm trying to run this command and see whether it is working.

16
00:00:59,000 --> 00:01:04,000
You can see we, we are having an error which is config server depends on undefined service.

17
00:01:04,000 --> 00:01:04,000
Rabbit.

18
00:01:04,000 --> 00:01:08,000
We missed one more update here like under the config server.

19
00:01:08,000 --> 00:01:13,000
As of now we have mentioned this rabbit service name under the depends on of my config server, but

20
00:01:13,000 --> 00:01:17,000
we are no more using the spring cloud bus related changes.

21
00:01:17,000 --> 00:01:20,000
But we already deleted this service name.

22
00:01:20,000 --> 00:01:26,000
That's why it is not going to make sense for docker compose and with that reason it is throwing an error.

23
00:01:26,000 --> 00:01:29,000
So let me remove this post that I'm going to save

24
00:01:29,000 --> 00:01:32,000
this changes and run the command again. This time hope for the best.

25
00:01:32,000 --> 00:01:38,000
First, you can see all my database related containers are trying to get created.

26
00:01:38,000 --> 00:01:45,000
Once all my database containers are created, then only my individual microservices like accounts,

27
00:01:45,000 --> 00:01:46,000
loans and cards microservices.

28
00:01:46,000 --> 00:01:48,000
They will try to get started.

29
00:01:48,000 --> 00:01:50,000
So let's wait for this to get completed.

30
00:01:50,000 --> 00:01:57,000
Since I have started my docker compose command without -d, I am able to see all the logs in the

31
00:01:57,000 --> 00:01:59,000
current terminal itself.

32
00:01:59,000 --> 00:02:04,000
So that's why it is very important to run in a detached mode so that your terminal will get free and

33
00:02:04,000 --> 00:02:06,000
you can run the other commands.

34
00:02:06,000 --> 00:02:11,000
I have waited for a few more seconds behind the scenes and all of my containers should have started

35
00:02:11,000 --> 00:02:12,000
successfully.

36
00:02:12,000 --> 00:02:17,000
Let me validate the same inside that Docker desktop. And you are going to have a surprise here.

37
00:02:17,000 --> 00:02:22,000
Inside my Docker desktop, you can see all my containers started like cards database, loans database

38
00:02:22,000 --> 00:02:27,000
accounts database and config server started and account microservice started.

39
00:02:27,000 --> 00:02:32,000
But you can see cards and loans microservices, they have not started.

40
00:02:32,000 --> 00:02:35,000
So let's try to see what is the reason by clicking on this.

41
00:02:35,000 --> 00:02:40,000
And from the log I can clearly see that it is not able to connect with the database.

42
00:02:40,000 --> 00:02:41,000
What is the issue?

43
00:02:41,000 --> 00:02:42,000
Let's try to understand this.

44
00:02:42,000 --> 00:02:47,000
This is going to be super interesting and you are understanding on Docker is going to get improved.

45
00:02:47,000 --> 00:02:52,000
So here if you see this is the connection details that I have given for accounts microservice, it is

46
00:02:52,000 --> 00:02:53,000
working fine.

47
00:02:53,000 --> 00:03:00,000
Whereas for loans database and cards database, we have given 3307 and 3308.

48
00:03:00,000 --> 00:03:06,000
You may question me like what is wrong with this because we have exposed 3307 and 3308 to the outside

49
00:03:06,000 --> 00:03:06,000
world.

50
00:03:06,000 --> 00:03:12,000
But if you see there is a catch here, the containers, they are within their own network.

51
00:03:12,000 --> 00:03:18,000
They are not trying to connect with your database from the external location or from the outside world.

52
00:03:18,000 --> 00:03:21,000
That's why here we should not give 3307.

53
00:03:21,000 --> 00:03:28,000
We should give 3306 itself where your loans database started inside the Docker network.

54
00:03:28,000 --> 00:03:30,000
So the same we need to give here.

55
00:03:30,000 --> 00:03:34,000
And in fact, if you see here, this port mapping itself is not needed.

56
00:03:34,000 --> 00:03:40,000
When my containers they are trying to communicate with each other, there is no need to expose my databases

57
00:03:40,000 --> 00:03:41,000
to the outside world.

58
00:03:41,000 --> 00:03:46,000
If you remove this port mapping, your microservices and DB containers, they are going to communicate

59
00:03:46,000 --> 00:03:48,000
with each other without any issues.

60
00:03:48,000 --> 00:03:53,000
But the reason why I'm trying to expose this to the outside world is, we want to validate whether the

61
00:03:53,000 --> 00:03:57,000
data is saved or not by using a client application like Sql Electron.

62
00:03:57,000 --> 00:04:03,000
So since I will be using SQL Electron, which will be outside the Docker network, so I need to make

63
00:04:03,000 --> 00:04:10,000
sure I'm exposing the traffic to the outside world with the port like 3306, 3307 and 3308.

64
00:04:10,000 --> 00:04:13,000
I hope you are understanding the concepts of Docker network.

65
00:04:13,000 --> 00:04:17,000
Now let me save this changes and try to create the containers again.

66
00:04:17,000 --> 00:04:19,000
This time it should be successful.

67
00:04:19,000 --> 00:04:22,000
I'm going to stop all the containers by pressing Ctrl C.

68
00:04:22,000 --> 00:04:27,000
This will not delete my containers, so to delete all the containers I need to run the command which

69
00:04:27,000 --> 00:04:31,000
is docker compose down. So that will remove the containers.

70
00:04:31,000 --> 00:04:34,000
Now I'm going to run the docker compose up command.

71
00:04:34,000 --> 00:04:40,000
This time I will run with -d and see if all our microservices they are going to start or not.

72
00:04:40,000 --> 00:04:47,000
Meanwhile, I'm going to create the Docker compose files for the other environments like Prod and qa.

73
00:04:47,000 --> 00:04:49,000
We know this is super,super easy task.

74
00:04:49,000 --> 00:04:54,000
So first I'm going to take all the content of the Docker compose file and I'm going to paste the same

75
00:04:54,000 --> 00:04:59,000
inside the Docker compose file of prod profile and let me do the same for QA as well.

76
00:04:59,000 --> 00:05:06,000
After this, I can open the commonconfig.yml and take the content from the default profile

77
00:05:06,000 --> 00:05:09,000
and mention the same inside the prod profile.

78
00:05:09,000 --> 00:05:14,000
But here, the only change that we need to do is to change the spring profiles active to prod.

79
00:05:14,000 --> 00:05:20,000
And very similarly, I'm going to take this content and paste the same inside the common-config.yml 

80
00:05:20,000 --> 00:05:22,000
and here the profile should be qa.

81
00:05:22,000 --> 00:05:27,000
So with this we have successfully updated the prod and docker compose Yaml files also.

82
00:05:27,000 --> 00:05:29,000
Now let me go to the Docker desktop .

83
00:05:29,000 --> 00:05:34,000
Here you can see this time all of my seven containers they started successfully.

84
00:05:34,000 --> 00:05:40,000
I can also confirm by clicking on this cards microservice and you can see it is still getting started.

85
00:05:40,000 --> 00:05:42,000
Let's wait for a couple of more seconds.

86
00:05:42,000 --> 00:05:46,000
This time the connection with the database is successful.

87
00:05:46,000 --> 00:05:49,000
That's why you can see here you're able to see these like added connection.

88
00:05:49,000 --> 00:05:52,000
It created a connection and finally it started my CardsApplication.

89
00:05:52,000 --> 00:05:57,000
The same might be the scenario inside the loans microservice here also it started.

90
00:05:57,000 --> 00:05:59,000
Now I can quickly test my REST APIs.

91
00:05:59,000 --> 00:06:02,000
First, I'm going to test the Create account

92
00:06:02,000 --> 00:06:05,000
by sending this request, I should get a successful response.

93
00:06:05,000 --> 00:06:07,000
Yeah, I got a successful response.

94
00:06:07,000 --> 00:06:13,000
Now let me go to the cards and here I'm going to click Create Card and I'm getting a successful response

95
00:06:13,000 --> 00:06:17,000
and I'll do the same for loans by clicking on this create loan.

96
00:06:17,000 --> 00:06:19,000
Here I'm trying to invoke this request.

97
00:06:19,000 --> 00:06:22,000
You can see we are getting a successful response for our loans API as well.

98
00:06:22,000 --> 00:06:29,000
So now let me go to the Sql electron and try to validate if the data is saved inside the database or not.

99
00:06:29,000 --> 00:06:34,000
Here, the same connection details will work because we are using the same port number and the same

100
00:06:34,000 --> 00:06:34,000
passwords.

101
00:06:34,000 --> 00:06:40,000
So let me try to connect to these loans database first and open this and look for that data

102
00:06:40,000 --> 00:06:45,000
inside the accounts there is data and let me do the same for customers. Inside customer

103
00:06:45,000 --> 00:06:46,000
also there is data.

104
00:06:46,000 --> 00:06:52,000
As a next step, I can validate loans also and inside the loans table also we have some data.

105
00:06:52,000 --> 00:06:54,000
Let me go back and click on this Cards database.

106
00:06:54,000 --> 00:06:56,000
And here also we have a table.

107
00:06:56,000 --> 00:06:58,000
And inside this table we also have data.

108
00:06:58,000 --> 00:07:04,000
This way we establish the communication between microservices and a MySQL database

109
00:07:04,000 --> 00:07:06,000
even with the Docker compose as well.

110
00:07:06,000 --> 00:07:12,000
Here you may have a question like inside my project, we are not using Docker containers, we are using

111
00:07:12,000 --> 00:07:16,000
some dev database or we are using some database inside the cloud.

112
00:07:16,000 --> 00:07:20,000
So whatever reason you are using some database which is not inside your local system.

113
00:07:20,000 --> 00:07:23,000
In such scenarios, the change is very simple.

114
00:07:23,000 --> 00:07:27,000
You don't have to mention all these accounts database, loans database, cards database.

115
00:07:27,000 --> 00:07:34,000
You can directly go to your individual microservices and mention your exact data source URL. So you can

116
00:07:34,000 --> 00:07:40,000
give the hostname of your development environment or the public IP which you got from the cloud environment.

117
00:07:40,000 --> 00:07:42,000
Provide those details directly here.

118
00:07:42,000 --> 00:07:46,000
And with that, your microservices will be able to connect with an external database.

119
00:07:46,000 --> 00:07:48,000
I hope this is clear,

120
00:07:48,000 --> 00:07:50,000
thank you and I'll catch you in the next lecture bye.


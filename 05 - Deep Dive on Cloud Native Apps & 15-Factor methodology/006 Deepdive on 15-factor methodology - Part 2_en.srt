1
00:00:00,000 --> 00:00:05,000
The next principle that we have inside the 15 factor methodology is logs.

2
00:00:05,000 --> 00:00:10,000
Inside a traditional application are a monolithic application, how the locks are handled.

3
00:00:10,000 --> 00:00:15,000
The application will write the locks into a file and folder location of your server.

4
00:00:15,000 --> 00:00:22,000
So if there are any issue comes inside your monolithic application, developers will go to that lock

5
00:00:22,000 --> 00:00:22,000
location.

6
00:00:22,000 --> 00:00:29,000
They will try to open the lock related to a specific date and timestamp and they will try to look at

7
00:00:29,000 --> 00:00:30,000
the locks

8
00:00:30,000 --> 00:00:32,000
what happened, what is the issue, what is the exception?

9
00:00:32,000 --> 00:00:39,000
But do you think this is going to work very similarly inside the microservice or cloud native applications?

10
00:00:39,000 --> 00:00:43,000
Off course not, because you will have 100 difference of microservice.

11
00:00:43,000 --> 00:00:48,000
If there is any issue, are you going to look and search in all the 100 different servers or in all

12
00:00:48,000 --> 00:00:52,000
the 100 different locations where your applications are going to write the locks?

13
00:00:53,000 --> 00:00:54,000
That is not going to be a feasible option.

14
00:00:54,000 --> 00:01:02,000
That's why as per these methodology, it is recommended that all the log routing and storage are not

15
00:01:02,000 --> 00:01:06,000
the applications concerned or cloud native applications are microservices

16
00:01:06,000 --> 00:01:12,000
they are not going to write the logs inside any log folder or inside any log location.

17
00:01:12,000 --> 00:01:19,000
Instead, the application will simply redirect the logs to the standard output, treating them as a

18
00:01:19,000 --> 00:01:22,000
sequentially ordered events based upon the time.

19
00:01:22,000 --> 00:01:29,000
The responsibility of the log storage and the rotation should be shifted to an external tool called

20
00:01:29,000 --> 00:01:30,000
log aggregator.

21
00:01:30,000 --> 00:01:36,000
This tool retrieves, gathers and provides access to the logs for the debugging purpose.

22
00:01:36,000 --> 00:01:42,000
So if you see here, there is an accounts microservice, loans microservice and cards microservice.

23
00:01:42,000 --> 00:01:48,000
They will simply print the logs to an standard output based upon the log statements and log framework

24
00:01:48,000 --> 00:01:49,000
that they use.

25
00:01:49,000 --> 00:01:54,000
And behind the scenes, there will be a log aggregator tool that will keep on pulling for the logs,

26
00:01:54,000 --> 00:02:00,000
and all these logs will be aggregated in a single location so that the developer or operations team,

27
00:02:00,000 --> 00:02:06,000
they can search all the logs of all the microservice with the help of this log aggregator tool.

28
00:02:06,000 --> 00:02:08,000
So this is one of the guiding principle.

29
00:02:08,000 --> 00:02:13,000
There is a separate section inside this course where with the help of a log aggregator tool, we will

30
00:02:13,000 --> 00:02:19,000
feed all the logs from all the microservice into that tool and we are going to search all the logs of

31
00:02:19,000 --> 00:02:24,000
all the microservice from a single UI log aggregator tool.

32
00:02:24,000 --> 00:02:30,000
So all these principles are very important and we are going to use a lot of tools and solutions to implement

33
00:02:30,000 --> 00:02:32,000
and achieve all these guiding principles.

34
00:02:32,000 --> 00:02:40,000
Now moving on to the next methodology, which is disposability inside a traditional monolithic application,

35
00:02:40,000 --> 00:02:46,000
making sure that a single monolithic application is always running is a top priority, and there is

36
00:02:46,000 --> 00:02:51,000
no room for this monolithic application to terminate or to get stopped.

37
00:02:51,000 --> 00:02:57,000
However, inside a cloud environment or inside cloud native applications or inside microservices, it

38
00:02:57,000 --> 00:03:04,000
is not going to super, super critical and necessary as well because you will have hundreds of microservices

39
00:03:04,000 --> 00:03:06,000
and they'll be having multiple instances running.

40
00:03:06,000 --> 00:03:13,000
It is really not possible to manually monitor and making sure and all these instances and microservices

41
00:03:13,000 --> 00:03:15,000
are running always.

42
00:03:15,000 --> 00:03:21,000
That's why applications in the cloud are always considered as ephemeral, meaning that if a particular

43
00:03:21,000 --> 00:03:28,000
microservice or a cloud native application becomes unresponsive, it can be terminated and replaced

44
00:03:28,000 --> 00:03:34,000
with a new instance by platforms like Kubernetes automatically and at the same time, during high load

45
00:03:34,000 --> 00:03:40,000
periods or during high load traffic, additional instances of the applications can be spin up to handle

46
00:03:40,000 --> 00:03:42,000
the increased workload.

47
00:03:42,000 --> 00:03:50,000
This concept of shutting down and creating new instances automatically is called application disposability,

48
00:03:50,000 --> 00:03:54,000
where the applications can be started or stopped as needed.

49
00:03:54,000 --> 00:04:01,000
But in order to make our applications disposablity and manage our applications in the dynamic environments

50
00:04:01,000 --> 00:04:07,000
like cloud, it is crucial to design them for quick startup when new instances are required and for

51
00:04:07,000 --> 00:04:10,000
graceful shutdown when they are no longer needed.

52
00:04:10,000 --> 00:04:16,000
This fast startup enables systems elasticity and ensuring robustness and resilience.

53
00:04:16,000 --> 00:04:23,000
Without these fast capabilities, performance and availability issues may arise like we discussed before,

54
00:04:23,000 --> 00:04:29,000
with the help of Spring boot framework and Docker containers, any microservice we can create and destroy

55
00:04:29,000 --> 00:04:30,000
within seconds.

56
00:04:30,000 --> 00:04:36,000
Whereas with virtual machines and monolithic applications, it is going to take at least 10 to 15 minutes.

57
00:04:36,000 --> 00:04:41,000
So that's why we are following Docker containers along with the useful framework like Spring Boot.

58
00:04:41,000 --> 00:04:48,000
And whenever a graceful shutdown is being involved for an application, the application should be capable

59
00:04:48,000 --> 00:04:56,000
of not accepting any new request and at the same time any ongoing requests should be processed successfully

60
00:04:56,000 --> 00:04:58,000
and then only it should exit.

61
00:04:58,000 --> 00:04:59,000
So this process is going to

62
00:04:59,000 --> 00:05:02,000
be pretty straightforward for a web applications.

63
00:05:02,000 --> 00:05:09,000
However, for worker process or any other type of process, it involves returning any pending jobs to

64
00:05:09,000 --> 00:05:12,000
the worker queues before exiting.

65
00:05:12,000 --> 00:05:17,000
This conveys that always graceful shutdown is also important.

66
00:05:17,000 --> 00:05:24,000
We should not ignore the existing requests that are being processed by a particular instance or a microservice

67
00:05:24,000 --> 00:05:30,000
that we are trying to shut down. When we use Docker container along with an orchestrator like Kubernetes,

68
00:05:30,000 --> 00:05:35,000
they are going to inherently satisfy these disposable requirement.

69
00:05:35,000 --> 00:05:40,000
That's why inside this course also we already started using Docker and by the end of this course, I'm

70
00:05:40,000 --> 00:05:46,000
also going to introduce you to Kubernetes and I'll run all our microservices inside Kubernetes cluster

71
00:05:46,000 --> 00:05:47,000
as well.

72
00:05:47,000 --> 00:05:52,000
Now moving on to the next principle, which is backing services.

73
00:05:52,000 --> 00:06:01,000
Your microservices may have dependency on many other external resources like database Smtp servers,

74
00:06:01,000 --> 00:06:04,000
FTP servers, caching systems, message brokers.

75
00:06:04,000 --> 00:06:09,000
So all these external resource dependencies, we call them as backing resources.

76
00:06:09,000 --> 00:06:16,000
So we should always treat these backing resources as attached resources so that we can modify or replace

77
00:06:16,000 --> 00:06:21,000
them without needing to make any changes inside your application code.

78
00:06:21,000 --> 00:06:27,000
For example, consider the use case of a database throughout your software development life cycle.

79
00:06:27,000 --> 00:06:32,000
Typically, different database are used in different stages, such as development, testing and production.

80
00:06:32,000 --> 00:06:39,000
We should always treat these database as an attached resource so that you can easily switch to an different

81
00:06:39,000 --> 00:06:41,000
service depending on the environment.

82
00:06:41,000 --> 00:06:46,000
How these attachment is going to work through resource bonding, which involves providing necessary

83
00:06:46,000 --> 00:06:53,000
information like URL, username and password of the database through externalized configurations.

84
00:06:53,000 --> 00:06:58,000
So once you generate a Docker image, you should not be generating the Docker image again and again

85
00:06:58,000 --> 00:07:04,000
whenever you want to change to your different database, instead to the same code base, you need to

86
00:07:04,000 --> 00:07:11,000
provide these URL information, user information and password information from an external configuration.

87
00:07:11,000 --> 00:07:15,000
Like you can see here, there is an app which is using local database.

88
00:07:15,000 --> 00:07:22,000
If needed, I can easily switch to an AWS database or any other external backing service by changing

89
00:07:22,000 --> 00:07:25,000
these URL details and connection details.

90
00:07:25,000 --> 00:07:26,000
I hope this is clear.

91
00:07:26,000 --> 00:07:31,000
Now let's go to the next principle that we have, which is environment parity.

92
00:07:31,000 --> 00:07:38,000
As per this guiding principle, it is recommended to minimize the differences between various environments

93
00:07:38,000 --> 00:07:43,000
of your application and also avoid any costly shortcuts.

94
00:07:43,000 --> 00:07:48,000
If your environments they look very similar, then your application also is going to work in a very

95
00:07:48,000 --> 00:07:49,000
similar manner.

96
00:07:49,000 --> 00:07:51,000
Just to fix some issue,

97
00:07:51,000 --> 00:07:57,000
if you are making some changes inside an environment by using shortcuts, then the behavior is going

98
00:07:57,000 --> 00:08:00,000
to be different for different, different environments.

99
00:08:00,000 --> 00:08:06,000
That's why this environment parity recommends to make sure all your environments are looking exactly

100
00:08:06,000 --> 00:08:08,000
as much as possible.

101
00:08:08,000 --> 00:08:13,000
When we use these environment parity, we are going to address three different type of gaps.

102
00:08:13,000 --> 00:08:16,000
The very first gap is time gap.

103
00:08:16,000 --> 00:08:21,000
Usually the time it takes for a code change to be deployed can be significant, but this methodology

104
00:08:21,000 --> 00:08:28,000
encourages automation like adopting CI/CD pipelines and perform continuous deployment to reduce the

105
00:08:28,000 --> 00:08:32,000
time between the code development and production deployment.

106
00:08:32,000 --> 00:08:37,000
This will make sure always your environments are looking similar and it is going to make developers

107
00:08:37,000 --> 00:08:40,000
life easy to perform any debugging.

108
00:08:40,000 --> 00:08:43,000
The next gap it is going to address is people gap.

109
00:08:43,000 --> 00:08:48,000
Usually developers, they create applications while platform operators

110
00:08:48,000 --> 00:08:50,000
they handle the deployment in production.

111
00:08:50,000 --> 00:08:53,000
To bridge this gap, a DevOps culture should be followed.

112
00:08:53,000 --> 00:09:00,000
And this DevOps culture, it promotes collaboration between developers and operators, fostering the

113
00:09:00,000 --> 00:09:03,000
philosophy, which is you build it, you run it.

114
00:09:03,000 --> 00:09:08,000
When the people gap is reduced, then there will be more coordination and collaboration, which will

115
00:09:08,000 --> 00:09:11,000
help to make environments look very similar.

116
00:09:11,000 --> 00:09:15,000
And with that, the number of issues are going to be less.

117
00:09:15,000 --> 00:09:21,000
And even if an issue comes since the environment are looking same, debugging is going to be easy.

118
00:09:21,000 --> 00:09:25,000
The last gap that this factor is going to address is tools gap.

119
00:09:25,000 --> 00:09:30,000
Like we discussed previously, applications can always use backing services and sometimes they can differ

120
00:09:30,000 --> 00:09:33,000
from environment to environment.

121
00:09:33,000 --> 00:09:39,000
For a microservice, a developer might use an H2 database locally, but in production they might be

122
00:09:39,000 --> 00:09:41,000
using PostgreSQL.

123
00:09:41,000 --> 00:09:47,000
This is not recommended because to achieve the environment parity we need to make sure we are using

124
00:09:47,000 --> 00:09:53,000
the same type of tool and the same version of the backing service across all environment.

125
00:09:53,000 --> 00:09:59,000
If you maintain different type and versions of backing services in different environments, then definitely

126
00:09:59,000 --> 00:09:59,000
the

127
00:09:59,000 --> 00:10:05,000
developer will code his business logic that is going to work with a H2 database and the same code

128
00:10:05,000 --> 00:10:08,000
base may not work for the Postgres SQL.

129
00:10:08,000 --> 00:10:14,000
That's why it is very important to use the same backing services in all the environments.

130
00:10:14,000 --> 00:10:18,000
The next factor at the principle that we have is administrative process.

131
00:10:18,000 --> 00:10:25,000
Many times we will be having many management tasks required to support application such as database

132
00:10:25,000 --> 00:10:30,000
migration, any batch jobs to clean the data or to update the data.

133
00:10:30,000 --> 00:10:36,000
So all these maintenance tasks and management tasks, they should be treated as isolated process. Similar

134
00:10:36,000 --> 00:10:38,000
to application process.

135
00:10:38,000 --> 00:10:45,000
The code for these administrative or management tasks should be version controlled and packaged along

136
00:10:45,000 --> 00:10:49,000
with the application and executed within the same environment.

137
00:10:49,000 --> 00:10:55,000
Many times developers, they will try to skip these administrative tasks running in the local dev or QA.

138
00:10:56,000 --> 00:11:01,000
For example, they don't run these batch jobs or data migrations, any maintenance tasks just to save

139
00:11:01,000 --> 00:11:05,000
some time and so that they can deploy the code into production quickly.

140
00:11:05,000 --> 00:11:09,000
But that will sometimes bring surprising results in production.

141
00:11:09,000 --> 00:11:15,000
That's why we should make sure these management and administrative processes are also equally important

142
00:11:15,000 --> 00:11:21,000
and they are treated as a separate isolated process and they are also properly tracked using versioning

143
00:11:21,000 --> 00:11:27,000
system and packaged along with the application and deployed in each environment where the application

144
00:11:27,000 --> 00:11:28,000
is being deployed.

145
00:11:28,000 --> 00:11:35,000
It is always advisable to consider these administrative tasks as independent microservices where they

146
00:11:35,000 --> 00:11:38,000
are executed only once and when they are not needed.

147
00:11:38,000 --> 00:11:39,000
We can discard them.

148
00:11:39,000 --> 00:11:46,000
If you try to put these administrative process inside your business logic, then you are unnecessarily

149
00:11:46,000 --> 00:11:50,000
carrying all these administrative tasks inside your microservice.

150
00:11:50,000 --> 00:11:56,000
Instead, if you keep your microservice business logic and these administrative tasks separately, once

151
00:11:56,000 --> 00:12:01,000
you are done with these administrative tasks, you can discard them so that your microservice alone

152
00:12:01,000 --> 00:12:04,000
can run continuously and serve its clients.

153
00:12:04,000 --> 00:12:10,000
Alternatively, these administrative tasks, they can also be integrated directly into the application,

154
00:12:10,000 --> 00:12:14,000
which can be activated by calling a designated endpoint.

155
00:12:14,000 --> 00:12:18,000
But it is always better to deploy them as an independent microservice.

156
00:12:18,000 --> 00:12:22,000
Now we are done with the ten different principles and guidelines.

157
00:12:22,000 --> 00:12:28,000
In the next lecture, let's try to discuss the last five guidelines and principles that we have inside

158
00:12:28,000 --> 00:12:30,000
the 15 factor methodology.

159
00:12:30,000 --> 00:12:33,000
Thank you and I'll catch you in the next lecture bye.


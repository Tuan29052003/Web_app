1
00:00:00,000 --> 00:00:01,000
Inside this lecture,

2
00:00:01,000 --> 00:00:08,000
let me try to convince you why we need a separate edge server inside our microservice network.

3
00:00:08,000 --> 00:00:09,000
For few seconds

4
00:00:09,000 --> 00:00:15,000
let's assume you are not agreeing with me and you decided to not go with a separate edge server for

5
00:00:15,000 --> 00:00:17,000
all your external communication.

6
00:00:17,000 --> 00:00:22,000
With that assumption, let's try to understand what are the challenges or what are the disadvantages

7
00:00:22,000 --> 00:00:25,000
that you may face inside your microservices development.

8
00:00:25,000 --> 00:00:31,000
Like you can see first we'll be having our individual microservices like accounts, loans and cards

9
00:00:31,000 --> 00:00:34,000
deployed in the respective servers and containers.

10
00:00:34,000 --> 00:00:40,000
Now all the external clients who want to communicate with our microservices, they are going to send

11
00:00:40,000 --> 00:00:44,000
the request directly to the respective microservice.

12
00:00:44,000 --> 00:00:47,000
Here we have three different client applications.

13
00:00:47,000 --> 00:00:50,000
They are trying to communicate with the three different microservices.

14
00:00:50,000 --> 00:00:56,000
In real projects you may have more than 100 microservices as well, and all those individual microservices,

15
00:00:56,000 --> 00:01:02,000
if they start receiving the external communication directly from the clients, we will be facing a lot

16
00:01:02,000 --> 00:01:04,000
of challenges and disadvantages.

17
00:01:04,000 --> 00:01:11,000
For example, if you want to implement some non-functional requirements or cross-cutting concerns like

18
00:01:11,000 --> 00:01:17,000
security, auditing, logging and routing, you need to repeat the business logic related to these and

19
00:01:17,000 --> 00:01:21,000
cross-cutting concerns inside all of your microservices.

20
00:01:21,000 --> 00:01:27,000
And in the same process, different developers may get assigned to build these cross-cutting concerns

21
00:01:27,000 --> 00:01:28,000
in different microservices.

22
00:01:28,000 --> 00:01:35,000
Here, there is no guarantee that all the developers, they will follow same standards while implementing

23
00:01:35,000 --> 00:01:37,000
the cross-cutting concerns.

24
00:01:37,000 --> 00:01:44,000
With that, there won't be any consistency inside your microservices in terms of enforcing security,

25
00:01:44,000 --> 00:01:46,000
auditing, logging and routing etc.

26
00:01:46,000 --> 00:01:47,000
.

27
00:01:47,000 --> 00:01:53,000
To overcome this challenge of inconsistency from various developers, you may try to propose a solution

28
00:01:53,000 --> 00:01:59,000
saying that, why can't we build all this logic inside a common library and try to add this common library

29
00:01:59,000 --> 00:02:02,000
as a dependency for all the microservices?

30
00:02:02,000 --> 00:02:08,000
That's a great advice, but let me try to explain what are the disadvantages that we may have here. Whenever

31
00:02:08,000 --> 00:02:13,000
we try to build these non-functional requirements and cross-cutting concerns into a common shared library,

32
00:02:13,000 --> 00:02:20,000
you are bringing a tight coupling between your common library and your microservices. In future, whenever

33
00:02:20,000 --> 00:02:25,000
you are trying to change some business logic on the security implementation or auditing or logging,

34
00:02:25,000 --> 00:02:32,000
you need to make sure that your common library is working with all the microservices without affecting

35
00:02:32,000 --> 00:02:33,000
them negatively.

36
00:02:33,000 --> 00:02:37,000
Which means you need to do regression testing and enough impact analysis.

37
00:02:37,000 --> 00:02:43,000
If you have more number of microservices inside your organization, doing the impact analysis and doing

38
00:02:43,000 --> 00:02:46,000
the regression may not be a feasible option.

39
00:02:46,000 --> 00:02:52,000
That's why even having all these cross-cutting concerns inside a common library is also a not recommended

40
00:02:52,000 --> 00:02:55,000
approach. To address all these challenges

41
00:02:55,000 --> 00:03:01,000
it will be a wise decision to have a single gateway which will act as an entry point into the microservice

42
00:03:01,000 --> 00:03:02,000
network.

43
00:03:02,000 --> 00:03:08,000
So let's try to understand how the Edge server or a Gateway server is going to help us to overcome these

44
00:03:08,000 --> 00:03:09,000
challenges.

45
00:03:09,000 --> 00:03:15,000
First, we'll be having similar accounts, loans and cards microservices inside our microservice network.

46
00:03:15,000 --> 00:03:21,000
Now, in between the client applications and these individual microservices, there will be an Edge

47
00:03:21,000 --> 00:03:28,000
server or the API Gateway server sitting and it is going to accept all the requests from the external

48
00:03:28,000 --> 00:03:32,000
clients and execute any business logic related to cross-cutting concerns.

49
00:03:32,000 --> 00:03:37,000
Once everything about the request is validated, then only it is going to forward the request to the

50
00:03:37,000 --> 00:03:39,000
actual microservice.

51
00:03:39,000 --> 00:03:47,000
So the advantage with this approach is, your edge server is capable of implementing a lot of functionalities,

52
00:03:47,000 --> 00:03:50,000
including cross-cutting concerns like security, logging, auditing.

53
00:03:50,000 --> 00:03:56,000
Apart from these cross-cutting concerns, with the help of these edge server, you can also prevent

54
00:03:56,000 --> 00:04:02,000
cascading failures and make your downstream services fault tolerant and resilient

55
00:04:02,000 --> 00:04:04,000
to the exceptions or errors.

56
00:04:04,000 --> 00:04:10,000
So I'm going to explain how to make our microservices fault tolerant with the help of Edge Server in

57
00:04:10,000 --> 00:04:11,000
the coming sections.

58
00:04:11,000 --> 00:04:16,000
But for now, please note that using Gateway or Edge server, we can also make our downstream services

59
00:04:16,000 --> 00:04:19,000
fault tolerant and resilient in nature.

60
00:04:19,000 --> 00:04:26,000
Apart from these functionalities, we can also implement retries timeouts for all the internal service

61
00:04:26,000 --> 00:04:28,000
calls with the help of this edge server.

62
00:04:28,000 --> 00:04:34,000
And if needed, we can also enforce some quota related policies on the incoming traffic from a particular

63
00:04:34,000 --> 00:04:35,000
client.

64
00:04:35,000 --> 00:04:41,000
For example, think like you have various plans inside your organization and based upon a plan that

65
00:04:41,000 --> 00:04:45,000
is subscribed by a client, you want to enforce some quota limitations.

66
00:04:45,000 --> 00:04:49,000
Maybe you have plans like standard, premium and advance.

67
00:04:49,000 --> 00:04:55,000
So based upon these plans, you want to enforce different, different quota limitations on a respective

68
00:04:55,000 --> 00:04:55,000
client.

69
00:04:55,000 --> 00:04:59,000
All such quota limitations you can also achieve with the help of this

70
00:04:59,000 --> 00:05:02,000
edge server or API gateway.

71
00:05:02,000 --> 00:05:07,000
Since we have all these advantages, it will be a wise decision to have a separate edge server for all

72
00:05:07,000 --> 00:05:09,000
your microservices.

73
00:05:09,000 --> 00:05:14,000
Still, if you are not convinced with me on why we should have a separate edge server, let me try to

74
00:05:14,000 --> 00:05:22,000
show you a different perspective on what API Gateway or Edge server can handle inside your microservices.

75
00:05:22,000 --> 00:05:27,000
Like you can see here, we have clients applications and microservices. In between the microservices

76
00:05:27,000 --> 00:05:29,000
and client applications,

77
00:05:29,000 --> 00:05:35,000
our API Gateway or Edge Server is going to act as a mediator. Inside this API gateway

78
00:05:35,000 --> 00:05:41,000
I can implement many functionalities in the very first step, we have the external clients sending the

79
00:05:41,000 --> 00:05:47,000
request to the API gateway and my API gateway can perform validations on the request.

80
00:05:47,000 --> 00:05:53,000
It can do some include and exclude list where it can perform some checks related to blacklisting or

81
00:05:53,000 --> 00:05:55,000
whitelisting of the IP address.

82
00:05:55,000 --> 00:05:59,000
And very similarly, it can also perform some authentication and authorization.

83
00:05:59,000 --> 00:06:05,000
And after the authentication and authorization, we can also enforce some rate limit, which means we

84
00:06:05,000 --> 00:06:11,000
can limit the quantity of requests or the amount of requests coming from a particular client.

85
00:06:11,000 --> 00:06:18,000
And very similarly, API Gateway is capable of performing dynamic routing, service discovery, modify

86
00:06:18,000 --> 00:06:23,000
request and response, and if needed, it can also perform protocol conversion.

87
00:06:23,000 --> 00:06:29,000
Maybe all the external traffic you are trying to accept with the Https protocol, but you want to forward

88
00:06:29,000 --> 00:06:34,000
the request using Http protocol to all your microservices.

89
00:06:34,000 --> 00:06:40,000
So such kind of protocol conversion you can perform with the help of API gateway. So you can activate

90
00:06:40,000 --> 00:06:46,000
or deactivate all these functionalities of API gateway based upon your business requirements.

91
00:06:46,000 --> 00:06:52,000
There is no mandatory that you need to implement all these components inside your API gateway.

92
00:06:52,000 --> 00:06:58,000
And at the same time, this is not the full exhaustive list on what my API gateway is capable of.

93
00:06:58,000 --> 00:07:04,000
My API gateway can do more, but I'm trying to highlight here most commonly used functionalities of

94
00:07:04,000 --> 00:07:05,000
API gateway.

95
00:07:05,000 --> 00:07:12,000
So after performing all these validations and executing all the business logic related to these components,

96
00:07:12,000 --> 00:07:17,000
my API gateway is going to forward the request to the actual microservices.

97
00:07:17,000 --> 00:07:23,000
Apart from these regular positive scenario, we can also handle negative scenarios like implementing

98
00:07:23,000 --> 00:07:30,000
the exception handling, implementing circuit breaker to make our microservices fault tolerant and resilient

99
00:07:30,000 --> 00:07:30,000
in nature.

100
00:07:30,000 --> 00:07:35,000
We're going to discuss about Circuit Breaker in the coming sections, but for now, please note that

101
00:07:35,000 --> 00:07:41,000
using this circuit breaker implementation, we can make our microservices resilient in nature.

102
00:07:41,000 --> 00:07:48,000
And apart from these positive and negative scenarios, your API gateway is also capable of sending all

103
00:07:48,000 --> 00:07:54,000
the logging and monitoring related information to an tools like Grafana, where using these tools we

104
00:07:54,000 --> 00:08:00,000
can look all the logs or errors or monitoring related information using beautiful dashboards.

105
00:08:00,000 --> 00:08:06,000
And if needed, we can also integrate our API gateway with an Redis cache, which means you can write

106
00:08:06,000 --> 00:08:12,000
some business logic by leveraging the cache that you can store inside this Redis component.

107
00:08:12,000 --> 00:08:14,000
So these are all the capabilities of API Gateway.

108
00:08:14,000 --> 00:08:20,000
And here you may have a question like why can't our Eureka Server do all these tasks?

109
00:08:20,000 --> 00:08:26,000
It's a very valid question, but the purpose of Eureka Server is strictly to implement a separate pattern,

110
00:08:26,000 --> 00:08:29,000
which is service discovery and service registry.

111
00:08:29,000 --> 00:08:35,000
Apart from service discovery and service registration, your Eureka Server is not capable of performing

112
00:08:35,000 --> 00:08:40,000
all these non-functional related requirements or implementing cross-cutting concerns.

113
00:08:40,000 --> 00:08:46,000
That's why we need to go with the API gateway and this will also give flexibility to the organizations.

114
00:08:46,000 --> 00:08:51,000
If they don't want API gateway related functionality, they can simply ignore it and go with the Eureka

115
00:08:51,000 --> 00:08:52,000
server.

116
00:08:52,000 --> 00:08:57,000
If someone need both of them, they can use both these components having different, different servers

117
00:08:57,000 --> 00:09:03,000
or components handling different, different problems inside microservices will also give options to the

118
00:09:03,000 --> 00:09:07,000
organizations which one they want to pick and which one they want to ignore.

119
00:09:07,000 --> 00:09:13,000
Now, I'm assuming you are convinced that we need to implement these gateway inside our microservices.

120
00:09:13,000 --> 00:09:18,000
The very immediate question that you may have here is, this looks very complex to me how we are going

121
00:09:18,000 --> 00:09:22,000
to build such an edge server inside our microservices.

122
00:09:22,000 --> 00:09:26,000
But don't worry my friend, we have our friend like Spring Boot and Spring Cloud.

123
00:09:26,000 --> 00:09:32,000
Using these frameworks, we can easily build the gateway or edge server inside microservices.

124
00:09:32,000 --> 00:09:38,000
In the next lecture, let's try to understand more details on how Spring Cloud is going to help us in

125
00:09:38,000 --> 00:09:42,000
implementing these gateway inside our microservices.

126
00:09:42,000 --> 00:09:45,000
Thank you and I'll catch you in the next lecture bye.


1
00:00:00,000 --> 00:00:06,000
When someone is looking to migrate their legacy or monolithic application into the latest microservices

2
00:00:06,000 --> 00:00:11,000
architecture, then there is a design pattern that people can follow.

3
00:00:11,000 --> 00:00:15,000
This design pattern is Strangler Fig pattern.

4
00:00:15,000 --> 00:00:22,000
So let's try to understand what is this pattern and how it is going to help the developers and organizations

5
00:00:22,000 --> 00:00:25,000
to migrate into the microservices architecture.

6
00:00:25,000 --> 00:00:34,000
Strangler fig pattern is a software migration pattern used to gradually replace or refactor a legacy

7
00:00:34,000 --> 00:00:37,000
system with a new system.

8
00:00:37,000 --> 00:00:39,000
In this pattern, what is going to happen ?

9
00:00:39,000 --> 00:00:41,000
The legacy application

10
00:00:41,000 --> 00:00:48,000
it is going to be replaced with a modern approach piece by piece, without disrupting the existing functionality.

11
00:00:48,000 --> 00:00:54,000
And here you might be wondering how this design pattern got this name, which is Strangler fig pattern.

12
00:00:54,000 --> 00:00:57,000
There is a very interesting story behind that.

13
00:00:57,000 --> 00:01:05,000
This pattern gets its name from the way a strangler fig plant grows around an existing tree by slowly

14
00:01:05,000 --> 00:01:08,000
replacing until the original tree is no longer needed.

15
00:01:09,000 --> 00:01:13,000
You can also see here I have mentioned the various stages of a strangler fig plant.

16
00:01:13,000 --> 00:01:17,000
This is how the strangler fig plant is going to look like.

17
00:01:17,000 --> 00:01:20,000
If you see just around the main tree.

18
00:01:20,000 --> 00:01:22,000
A new plant is trying to grow.

19
00:01:22,000 --> 00:01:28,000
When it grows fully, the original tree or the main tree, it is going to be completely replaced.

20
00:01:28,000 --> 00:01:32,000
Here in the very first stage you can see this is the original tree.

21
00:01:32,000 --> 00:01:40,000
To this original tree, a small plant started to grow on the sides and this small plant, it started

22
00:01:40,000 --> 00:01:44,000
growing onto the main tree itself. The new tree,

23
00:01:44,000 --> 00:01:51,000
it is trying to gradually grow and eventually only the new tree is going to be present.

24
00:01:51,000 --> 00:01:56,000
And the old tree, it is going to die or it is going to be completely replaced.

25
00:01:56,000 --> 00:02:01,000
The same strategy is organizations they are going to follow whenever they are trying to migrate their

26
00:02:01,000 --> 00:02:03,000
the legacy application into microservices.

27
00:02:03,000 --> 00:02:10,000
Usually following this pattern is strongly recommended if you are trying to modernize a large or complex

28
00:02:10,000 --> 00:02:11,000
legacy system.

29
00:02:11,000 --> 00:02:16,000
If your legacy system is very small, then there is no need to follow these strangler fig pattern only

30
00:02:16,000 --> 00:02:19,000
for the complex or large legacy systems.

31
00:02:19,000 --> 00:02:20,000
Only this pattern is recommended.

32
00:02:20,000 --> 00:02:27,000
You can also follow this pattern when you want to avoid the risk associated with a complete system rewrite

33
00:02:27,000 --> 00:02:29,000
or a big bang migration.

34
00:02:29,000 --> 00:02:30,000
What is a Big Bang migration?

35
00:02:30,000 --> 00:02:35,000
Suddenly, on a single day, you are going to migrate from legacy system to the new system.

36
00:02:35,000 --> 00:02:39,000
This kind of migration system will call them as Big Bang migration.

37
00:02:39,000 --> 00:02:45,000
There are certain risks if you try to follow the Big Bang migration by rewriting the entire legacy system.

38
00:02:45,000 --> 00:02:50,000
To avoid such risk, you can follow the Strangler fig pattern at last

39
00:02:50,000 --> 00:02:56,000
you can also consider this pattern when the legacy system needs to remain operational during the transition

40
00:02:56,000 --> 00:02:57,000
to the new system.

41
00:02:57,000 --> 00:03:01,000
I hope you got some gist of these strangler fig pattern.

42
00:03:01,000 --> 00:03:04,000
Let me show you an example so that it is going to be clear for you.

43
00:03:04,000 --> 00:03:08,000
As you can see here, initially there was a monolithic app.

44
00:03:08,000 --> 00:03:14,000
Just imagine this is a bank application, inside this bank application

45
00:03:14,000 --> 00:03:18,000
it supports functionalities around the cards, accounts and loans.

46
00:03:18,000 --> 00:03:22,000
Entire functionality is present inside these monolithic app.

47
00:03:22,000 --> 00:03:26,000
So what the development team they are going to do whenever they are following the strangler fig pattern is,

48
00:03:26,000 --> 00:03:33,000
first they are going to decide how to rightsize their microservice by following that domain driven

49
00:03:33,000 --> 00:03:34,000
design approach.

50
00:03:34,000 --> 00:03:40,000
As a next step, the legacy monolithic is carefully broken down into distinct domains, and services

51
00:03:40,000 --> 00:03:45,000
are gradually rewritten using newer technologies.

52
00:03:45,000 --> 00:03:47,000
As you can see here, the development team

53
00:03:47,000 --> 00:03:53,000
first, they have created an accounts microservice and the remaining functionality is still present

54
00:03:53,000 --> 00:03:54,000
inside the monolithic app.

55
00:03:54,000 --> 00:03:57,000
The remaining functionality is related to the cards and loans microservice.

56
00:03:57,000 --> 00:04:03,000
Once they feel everything around the accounts microservice is properly working in production.

57
00:04:03,000 --> 00:04:09,000
What they are going to do is, they are going to migrate the next component into the microservice.

58
00:04:09,000 --> 00:04:16,000
The next component is, cards here, once they satisfied with the deployment of cards and accounts microservice

59
00:04:16,000 --> 00:04:21,000
into the microservices environment, if they are happy with the results and the progress that they made,

60
00:04:21,000 --> 00:04:24,000
eventually they will try to migrate their loans as well.

61
00:04:24,000 --> 00:04:32,000
And towards the end stage you can see there is no monolithic app here. Because it is completely replaced

62
00:04:32,000 --> 00:04:33,000
with this approach

63
00:04:33,000 --> 00:04:36,000
developers team, they are going to get lot of benefits.

64
00:04:36,000 --> 00:04:41,000
The very first benefit is there is, very minimal risk associated with these migration.

65
00:04:41,000 --> 00:04:47,000
Since the development team, they are trying to migrate only a piece of component into microservices.

66
00:04:47,000 --> 00:04:52,000
If there are some issues, they should be easily handled and whatever learnings they have learned during

67
00:04:52,000 --> 00:04:59,000
the first migration, those learnings will be used while they are migrating other components.

68
00:04:59,000 --> 00:05:01,000
And the next advantage is this pattern chain

69
00:05:01,000 --> 00:05:01,000
allow

70
00:05:01,000 --> 00:05:08,000
the development team to migrate incrementally instead of going for the Big Bang migration.

71
00:05:08,000 --> 00:05:11,000
With the Big Bang migration, we'll have a lot of challenges.

72
00:05:11,000 --> 00:05:12,000
You can't roll back easily.

73
00:05:12,000 --> 00:05:17,000
And if there are any surprises, it's very hard to handle them for the development team.

74
00:05:17,000 --> 00:05:22,000
Whereas with the incremental migration, the development team will have enough opportunities to learn

75
00:05:22,000 --> 00:05:26,000
from their mistakes, to handle the issues and surprises.

76
00:05:26,000 --> 00:05:31,000
And the last advantage that developers they're going to get when they're following this pattern is, this

77
00:05:31,000 --> 00:05:37,000
pattern is going to help in performing testing and validations with greater efficiency.

78
00:05:37,000 --> 00:05:43,000
Since monolithic application is also going to be present inside this migration, they can always try

79
00:05:43,000 --> 00:05:48,000
to route the traffic between the microservices and legacy application.

80
00:05:48,000 --> 00:05:52,000
They can test by routing the traffic between the two components.

81
00:05:52,000 --> 00:05:57,000
If there are any issues, they can compare the results between the legacy and the microservices.

82
00:05:57,000 --> 00:06:03,000
For some reason, if the microservices is not working as expected, then they can try to navigate the

83
00:06:03,000 --> 00:06:06,000
100% of the traffic to the monolithic application.

84
00:06:06,000 --> 00:06:13,000
Here, though, I'm trying to decrease the size of the monolithic app, but in reality, the accounts

85
00:06:13,000 --> 00:06:18,000
code and the cards code, it is going to still be present inside the monolithic app, but it will be

86
00:06:18,000 --> 00:06:21,000
in the dead state because there is no traffic is coming.

87
00:06:21,000 --> 00:06:24,000
But development team, like I said, they have flexibility.

88
00:06:24,000 --> 00:06:27,000
They can redirect 50-50% of the traffic between these two components.

89
00:06:27,000 --> 00:06:33,000
Once they are confident that microservices is working, they can send 100% of the traffic towards a

90
00:06:33,000 --> 00:06:33,000
microservice.

91
00:06:33,000 --> 00:06:38,000
Otherwise, they can roll back the traffic back to the monolithic application.

92
00:06:38,000 --> 00:06:43,000
Whenever someone is following this pattern, there are four different steps that they are going to follow.

93
00:06:43,000 --> 00:06:45,000
The very first one is Identification.

94
00:06:45,000 --> 00:06:50,000
As part of this identification process, they are going to identify how many microservices they need

95
00:06:50,000 --> 00:06:51,000
to do.

96
00:06:51,000 --> 00:06:56,000
Basically, they are going to perform the right sizing of the microservices by using the domain driven

97
00:06:56,000 --> 00:06:57,000
approach.

98
00:06:57,000 --> 00:07:03,000
The next stage is going to be the transformation where they are going to transform the components inside

99
00:07:03,000 --> 00:07:07,000
the legacy into the microservices. Once the transformation is successful.

100
00:07:07,000 --> 00:07:13,000
As you can see, both monolithic and microservices, they are going to be coexist.

101
00:07:13,000 --> 00:07:18,000
There will be a strangler facade introduced with the help of the strangler facade.

102
00:07:18,000 --> 00:07:22,000
The traffic between the legacy and the microservices can be handled.

103
00:07:22,000 --> 00:07:25,000
Usually this can be handled with the help of a API gateway.

104
00:07:25,000 --> 00:07:32,000
After the coexistence phase, at last, the elimination phase comes where they are going to completely

105
00:07:32,000 --> 00:07:39,000
eliminate the legacy application and the entire traffic will go to the microservices or the modern

106
00:07:39,000 --> 00:07:40,000
application.

107
00:07:40,000 --> 00:07:42,000
I hope you are clear with this pattern.

108
00:07:42,000 --> 00:07:47,000
Please make sure you are clear about this pattern because there is a very good chance inside the interviews,

109
00:07:47,000 --> 00:07:50,000
people may ask you around the migration.

110
00:07:50,000 --> 00:07:55,000
They can simply ask, how are you migrating your legacy into the microservice based application?

111
00:07:55,000 --> 00:07:56,000
The answer is very simple.

112
00:07:56,000 --> 00:07:59,000
You need to explain these Strangler fig pattern.

113
00:07:59,000 --> 00:08:02,000
Thank you and I'll catch you in the next lecture, bye.


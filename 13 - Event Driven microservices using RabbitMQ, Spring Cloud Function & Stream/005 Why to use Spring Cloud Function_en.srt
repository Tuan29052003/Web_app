1
00:00:00,000 --> 00:00:05,000
To get started with the implementation of asynchronous communication with the help of Rabbitmq.

2
00:00:05,000 --> 00:00:08,000
First, we need to create the message microservice.

3
00:00:09,000 --> 00:00:15,000
This message microservice is responsible to receive the messages from the message broker and send the

4
00:00:15,000 --> 00:00:20,000
communication to the end users using SMS and email.

5
00:00:20,000 --> 00:00:26,000
In order to build this message microservice we are not going to follow that traditional approach that

6
00:00:26,000 --> 00:00:32,000
we have followed for other microservices, which means I'm not going to build REST services by following

7
00:00:32,000 --> 00:00:36,000
traditional annotations like RestController, GetMapping PostMapping.

8
00:00:36,000 --> 00:00:40,000
Instead, I'm going to leverage spring cloud function.

9
00:00:40,000 --> 00:00:43,000
So what is this spring cloud function and why we need to leverage this

10
00:00:44,000 --> 00:00:46,000
for any event driven microservices.

11
00:00:46,000 --> 00:00:52,000
So let's try to understand the same spring cloud function, facilitate that development of business

12
00:00:52,000 --> 00:00:55,000
logic by utilizing functions.

13
00:00:55,000 --> 00:01:01,000
So whatever business logic that my developer want to write, he simply has to write the business logic

14
00:01:01,000 --> 00:01:08,000
inside the functions and the rest of the infrastructural concerns is going to be taken care by the spring

15
00:01:08,000 --> 00:01:09,000
cloud function.

16
00:01:09,000 --> 00:01:16,000
So how a developer has to write the business logic by adhering to the standard function interfaces available

17
00:01:16,000 --> 00:01:18,000
are introduced in Java eight.

18
00:01:18,000 --> 00:01:23,000
These functions are namely supplier function and consumer.

19
00:01:23,000 --> 00:01:28,000
I know you may have too many questions right now, but let me first try to explain you what is the supplier

20
00:01:28,000 --> 00:01:32,000
function and consumer post that I'm going to discuss,

21
00:01:32,000 --> 00:01:37,000
what are the advantages that we are going to get by building our business logic with the help of spring

22
00:01:37,000 --> 00:01:37,000
cloud function.

23
00:01:38,000 --> 00:01:41,000
The very first function type that we have here is supplier.

24
00:01:41,000 --> 00:01:49,000
A supplier is a function or a lambda expression that produces an output without requiring any input.

25
00:01:49,000 --> 00:01:53,000
It can also be referred as a producer, publisher or source.

26
00:01:53,000 --> 00:01:59,000
That means whenever you write your business logic using supplier functional interface, then your business

27
00:01:59,000 --> 00:02:02,000
logic is never going to expect any input.

28
00:02:02,000 --> 00:02:07,000
It's simply going to produce an event or produce an output.

29
00:02:07,000 --> 00:02:12,000
In simple words for your Supplier, Function interface, there won't be any input, but there will be

30
00:02:12,000 --> 00:02:13,000
an output.

31
00:02:13,000 --> 00:02:15,000
So that's why we will call it as Supplier.

32
00:02:15,000 --> 00:02:19,000
It is going to always supply the output without taking any input.

33
00:02:19,000 --> 00:02:22,000
Now similarly, we also have Function.

34
00:02:22,000 --> 00:02:25,000
What is a Function functional interface.

35
00:02:25,000 --> 00:02:29,000
This Function accepts inputs and generate an output.

36
00:02:29,000 --> 00:02:35,000
It is commonly referred as a processor because it is taking an input and it is going to process the

37
00:02:35,000 --> 00:02:37,000
input and post the processing

38
00:02:37,000 --> 00:02:39,000
It is going to generate an output.

39
00:02:39,000 --> 00:02:44,000
In simple words, your Function is going to accept an input and send an output.

40
00:02:44,000 --> 00:02:48,000
And the next function interface that we have here is Consumer.

41
00:02:48,000 --> 00:02:51,000
So Consumer is a quite opposite of Supplier.

42
00:02:51,000 --> 00:02:59,000
A Consumer is a function or a lambda expression that always consumes an input but does not produce any

43
00:02:59,000 --> 00:02:59,000
output.

44
00:02:59,000 --> 00:03:02,000
It can be called as a subscriber or sink.

45
00:03:02,000 --> 00:03:09,000
In simple words, your Consumer is always going to have an input, but it will never going to generate

46
00:03:09,000 --> 00:03:10,000
any output.

47
00:03:10,000 --> 00:03:15,000
It is always going to consume, consume, but not going to give any output.

48
00:03:15,000 --> 00:03:22,000
So these are the three different types of standard functional interfaces available inside the java8.

49
00:03:22,000 --> 00:03:28,000
Using these three functional interfaces, only the developers are required to implement their business

50
00:03:28,000 --> 00:03:30,000
logic with the help of functions.

51
00:03:30,000 --> 00:03:37,000
Can you imagine any business logic that can come beyond these three functional interfaces?

52
00:03:37,000 --> 00:03:42,000
Off course not, because we can either have a scenario where we are not taking any input but giving an

53
00:03:42,000 --> 00:03:48,000
output or we are going to take an input but not going to return any output.

54
00:03:48,000 --> 00:03:53,000
So always your business logic will fall into any of these three interfaces.

55
00:03:53,000 --> 00:03:59,000
Now coming to the question, why should you develop your business logic with the help of functions by

56
00:03:59,000 --> 00:04:02,000
leveraging these spring cloud function project?

57
00:04:02,000 --> 00:04:08,000
Because developing business logic with the help of spring cloud function is going to be simple and at

58
00:04:08,000 --> 00:04:15,000
the same time it is going to provide you a lot of flexibility to expose your business logic using various

59
00:04:15,000 --> 00:04:17,000
patterns. By default,

60
00:04:17,000 --> 00:04:23,000
all your logic that you are going to write inside your functions will be exposed as an REST API automatically

61
00:04:23,000 --> 00:04:29,000
by your spring cloud function and if needed, you can also integrate these spring cloud function with

62
00:04:29,000 --> 00:04:37,000
the event brokers like Rabbitmq, Apache Kafka by adding one more project which is Spring Cloud Stream.

63
00:04:37,000 --> 00:04:42,000
Now let's try to understand what more advantages we have whenever we are using spring cloud function.

64
00:04:42,000 --> 00:04:49,000
You can see here, whenever we are developing business logic with the help of functions, we can follow

65
00:04:49,000 --> 00:04:53,000
reactive approach or imperative approach or hybrid approach.

66
00:04:53,000 --> 00:04:59,000
And like I said before, all your business logic is going to be implemented with the help of simple

67
00:04:59,000 --> 00:05:00,000
pojo functions.

68
00:05:00,000 --> 00:05:06,000
And if needed, you can compose multiple functions to give a desired output.

69
00:05:06,000 --> 00:05:11,000
We are going to explore in the coming lectures how to write our business logic with the help of functions

70
00:05:11,000 --> 00:05:16,000
and how to club multiple functions to derive an expected output.

71
00:05:16,000 --> 00:05:21,000
And the next advantage that we have with the spring cloud functions is, like I said by default,

72
00:05:21,000 --> 00:05:28,000
all your functions are going to be exposed as a  http endpoints with the help of REST services

73
00:05:28,000 --> 00:05:36,000
and you can also stream data from these functions by integrating them with Apache Kafka Rabbitmq by

74
00:05:36,000 --> 00:05:38,000
using Spring Cloud stream framework.

75
00:05:38,000 --> 00:05:44,000
So which means the same business logic that you have written with the help of functions you can use

76
00:05:44,000 --> 00:05:51,000
as a REST APIs or you can also stream data by connecting them to the event brokers or if needed,

77
00:05:51,000 --> 00:05:57,000
you can package these functions for standalone deployments specific to a target environment like AWS

78
00:05:57,000 --> 00:05:59,000
lambda, which is a serverless environment.

79
00:05:59,000 --> 00:06:05,000
So there are unlimited options that you have how you want to expose the business logic that you have

80
00:06:05,000 --> 00:06:07,000
inside your spring cloud function.

81
00:06:07,000 --> 00:06:13,000
So if you try to build your business logic with the REST APIs, then you are only limited to the opportunities

82
00:06:13,000 --> 00:06:15,000
where the REST APIs are supported.

83
00:06:15,000 --> 00:06:17,000
How about streaming the data?

84
00:06:17,000 --> 00:06:22,000
Or how about deploying your business logic into the serverless environment?

85
00:06:22,000 --> 00:06:25,000
So whenever you are, infrastructural requirements are keep changing.

86
00:06:25,000 --> 00:06:31,000
You need to change a lot inside your microservices if you are following the traditional approach.

87
00:06:31,000 --> 00:06:36,000
Whereas with the spring cloud function, the developer will always focus on building the business logic

88
00:06:36,000 --> 00:06:41,000
with the help of functions and exposing that business logic with the various approach is going to be

89
00:06:41,000 --> 00:06:48,000
easily achieved by mentioning few properties inside application.yml file and this spring cloud

90
00:06:48,000 --> 00:06:55,000
function is best suitable for event driven architecture or event driven model because these functions

91
00:06:55,000 --> 00:07:00,000
give flexibility to us to take our business logic wherever we want.

92
00:07:00,000 --> 00:07:02,000
Today we have some technology in future,

93
00:07:02,000 --> 00:07:08,000
if some other technology comes, we can easily migrate from one technology to other technology with

94
00:07:08,000 --> 00:07:10,000
a minimum configuration.

95
00:07:10,000 --> 00:07:13,000
Let's try to explore the spring cloud function website.

96
00:07:13,000 --> 00:07:18,000
You can see here under the spring cloud, we have a sub project with the name Spring Cloud function.

97
00:07:18,000 --> 00:07:23,000
So these are the high level overview and what are the goals, why we need to use this spring cloud function.

98
00:07:23,000 --> 00:07:29,000
So it promotes and implements business logic via functions and decouple the development lifecycle of

99
00:07:29,000 --> 00:07:37,000
business logic from specific runtime target. So that the same code can run as a web point, which means

100
00:07:37,000 --> 00:07:45,000
REST APIs are a stream processor or a task, and it also supports running your business logic as a standalone,

101
00:07:45,000 --> 00:07:48,000
either in your local or in a pass environment.

102
00:07:48,000 --> 00:07:53,000
Apart from that, if you can scroll down here, you will be able to see that there are many adapters

103
00:07:53,000 --> 00:08:01,000
available to integrate your spring cloud functions with AWS lambda, Microsoft Azure, Apache Openwhisk.

104
00:08:01,000 --> 00:08:09,000
So all the majority of the serverless providers have adapters that we can use to integrate with the

105
00:08:09,000 --> 00:08:10,000
spring cloud functions.

106
00:08:10,000 --> 00:08:16,000
You can also click on this learn button and if you go to the official documentation inside this page,

107
00:08:16,000 --> 00:08:21,000
you can click on this reference guide where you will be redirected to the official document page.

108
00:08:21,000 --> 00:08:24,000
And here there are multiple sections available.

109
00:08:24,000 --> 00:08:29,000
If you want to learn more about spring cloud functions like if you want to deploy your spring cloud

110
00:08:29,000 --> 00:08:34,000
function as a standalone web application, you can try to refer this section.

111
00:08:34,000 --> 00:08:39,000
And very similarly, you can also deploy them as a standalone streaming applications.

112
00:08:39,000 --> 00:08:41,000
You can deploy it as a packaged function.

113
00:08:41,000 --> 00:08:46,000
And similarly here we have a section explaining about serverless platform adapters.

114
00:08:46,000 --> 00:08:53,000
Here there is official documentation on how to deploy your business logic with the help of spring cloud

115
00:08:53,000 --> 00:09:00,000
functions inside the serverless environments like AWS lambda, Microsoft Azure function, Google Cloud

116
00:09:00,000 --> 00:09:01,000
functions.

117
00:09:01,000 --> 00:09:08,000
So majority of the cloud providers and the serverless platforms are supported for spring cloud functions.

118
00:09:08,000 --> 00:09:14,000
Now I'm assuming you are with me on why we should also learn spring cloud function whenever we are trying

119
00:09:14,000 --> 00:09:20,000
to build microservices. Using this spring cloud functions, we can always build event driven microservice.

120
00:09:20,000 --> 00:09:26,000
In our scenario, we are going to build a new microservice with the name message and since this microservice

121
00:09:26,000 --> 00:09:33,000
is going to completely use event driven model, it will be a good decision to build this message

122
00:09:33,000 --> 00:09:36,000
microservice with the help of spring cloud function.

123
00:09:36,000 --> 00:09:41,000
From the next lecture, let's try to build our message microservice by leveraging spring cloud function.

124
00:09:41,000 --> 00:09:44,000
Thank you and I'll catch you in the next lecture bye.


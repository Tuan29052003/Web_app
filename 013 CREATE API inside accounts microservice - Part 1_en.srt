1
00:00:00,000 --> 00:00:04,000
Are you excited to build the actual business logic?

2
00:00:04,000 --> 00:00:09,000
Now is the time to build the actual business logic inside our

3
00:00:09,000 --> 00:00:15,000
Accounts Microservice. Inside this lecture, I'm going to build a REST API that will support the creation of a

4
00:00:15,000 --> 00:00:21,000
new account and new customer details inside our H2 database that we are maintaining.

5
00:00:21,000 --> 00:00:27,000
Please watch this video carefully because I'm going to cover a lot many standards, including exception

6
00:00:27,000 --> 00:00:32,000
handling, service layer logic and how to leverage the DTO pattern.

7
00:00:32,000 --> 00:00:37,000
So in order to create a new Rest API service, we need to go to the AccountsController.

8
00:00:37,000 --> 00:00:44,000
Because inside this controller class only we have created previously a sayHello API and right now we

9
00:00:44,000 --> 00:00:44,000
don't need this

10
00:00:44,000 --> 00:00:46,000
let me delete this

11
00:00:46,000 --> 00:00:53,000
say hello API. In real projects, whenever we are trying to build REST APIs, it is always recommended

12
00:00:53,000 --> 00:01:02,000
to maintain a prefix API path which is common for your entire REST APIs present inside your controller

13
00:01:02,000 --> 00:01:02,000
class.

14
00:01:02,000 --> 00:01:08,000
For the same, we need to mention the annotation which is RequestMapping to this annotation.

15
00:01:08,000 --> 00:01:13,000
I'm going to pass the path parameter and to this path parameter.

16
00:01:13,000 --> 00:01:20,000
For now I'm giving the prefix path as /api, which means any REST API that I'm trying to implement inside

17
00:01:20,000 --> 00:01:21,000
this controller class.

18
00:01:21,000 --> 00:01:26,000
It is going to have this prefix path inside API if needed few projects

19
00:01:26,000 --> 00:01:31,000
they also maintain the version number of the API like V1 or V2.

20
00:01:31,000 --> 00:01:37,000
But right now, since this is not a real project, we don't need to maintain these versioning inside

21
00:01:37,000 --> 00:01:38,000
our API paths.

22
00:01:38,000 --> 00:01:43,000
That's why I'm just going to mention the prefix as /api.

23
00:01:43,000 --> 00:01:49,000
After this, It is also good practice to mention what is a return type data format from your REST API.

24
00:01:49,000 --> 00:01:54,000
So we are going to support the return type data type as Json.

25
00:01:54,000 --> 00:01:59,000
That's why we need to mention producers = MediaType.

26
00:01:59,000 --> 00:02:05,000
Please make sure you are selecting the media type from the springframework.http package.

27
00:02:05,000 --> 00:02:11,000
Using this media type, we can invoke a constant which is APPLICATION_JSON_VALUE.

28
00:02:11,000 --> 00:02:14,000
Like you can see I'm just selecting that Json value.

29
00:02:14,000 --> 00:02:19,000
So this conforms to my spring boot framework that the REST API is that I'm going to implement inside

30
00:02:19,000 --> 00:02:25,000
this controller are inside this microservice, they are going to support the response type of type Json.

31
00:02:25,000 --> 00:02:29,000
So now I'm going to create a method that supports, create operation.

32
00:02:29,000 --> 00:02:37,000
So public ResponseEntity and inside this Response entity, I'm going to send the ResponseDto that

33
00:02:37,000 --> 00:02:42,000
we have created previously and the method name is going to be createAccount().

34
00:02:42,000 --> 00:02:48,000
And to this createAccount() , I'm going to accept the request from my client applications.

35
00:02:48,000 --> 00:02:54,000
That's why I need to mention the RequestBody with the help of RequestBody annotation, whatever

36
00:02:54,000 --> 00:02:57,000
my clients are sending inside the RequestBody.

37
00:02:57,000 --> 00:03:04,000
The same will be mapped into the Pojo class that I'm trying to mention after this RequestBody The Pojo

38
00:03:04,000 --> 00:03:06,000
class that I'm going to mention here is CustomerDto.

39
00:03:07,000 --> 00:03:14,000
This means anyone who is trying to invoke my createAccount  method, they need to pass the input by

40
00:03:14,000 --> 00:03:16,000
following the data present

41
00:03:16,000 --> 00:03:19,000
Inside this dto. They need to pass what is the name of the customer?

42
00:03:19,000 --> 00:03:21,000
What is the email of the customer?

43
00:03:21,000 --> 00:03:22,000
What is the mobile number.

44
00:03:22,000 --> 00:03:28,000
Now, on top of this method I need to mention the @PostMapping annotation because since

45
00:03:28,000 --> 00:03:36,000
this is a create operation like we discussed, we need to use Http post method and to this post method,

46
00:03:36,000 --> 00:03:40,000
the path that it is going to support is create.

47
00:03:40,000 --> 00:03:47,000
So anyone who wants to create a new account using my Accounts Microservice, they need to pass 

48
00:03:47,000 --> 00:03:53,000
/api, /create along with this input data, then only the invocation will work.

49
00:03:53,000 --> 00:03:57,000
So let me write some logic inside the body of my method.

50
00:03:57,000 --> 00:03:59,000
First, let me write return statement.

51
00:03:59,000 --> 00:04:03,000
I'm going to return the object of Response entity.

52
00:04:03,000 --> 00:04:08,000
That's why using Response entity class post, I'm going to send what is a status.

53
00:04:08,000 --> 00:04:15,000
And whenever the creation of account is successful, I want to mention the HttpStatus.CREATED.

54
00:04:15,000 --> 00:04:23,000
This means the given resource is created successfully in the backend server post that using body method,

55
00:04:23,000 --> 00:04:28,000
I'm going to send the object of ResponseDto that we have created.

56
00:04:28,000 --> 00:04:30,000
Let me invoke this ResponseDto

57
00:04:30,000 --> 00:04:37,000
constructor and to this constructor I need to pass what is the statusCode and statusMsg that

58
00:04:37,000 --> 00:04:38,000
I want to return?

59
00:04:38,000 --> 00:04:44,000
So let's maintain all the status code, status message or any other constant values inside a separate

60
00:04:44,000 --> 00:04:44,000
file.

61
00:04:44,000 --> 00:04:46,000
That is a recommended standard.

62
00:04:46,000 --> 00:04:51,000
That's why I'm going to create a new package with the name constants.

63
00:04:51,000 --> 00:04:57,000
Inside this constants package, I'm going to create a new class with the name AccountsConstants and

64
00:04:57,000 --> 00:04:59,000
inside this Accounts class I'm going to create

65
00:05:00,000 --> 00:05:00,000
constants.

66
00:05:00,000 --> 00:05:02,000
So let me paste this constants

67
00:05:02,000 --> 00:05:06,000
values. Like you can see have created all these constants.

68
00:05:06,000 --> 00:05:09,000
Please get these constants from the GitHub repo.

69
00:05:09,000 --> 00:05:15,000
I'm not typing all these values just to save some time here, so every constant has to be static and

70
00:05:15,000 --> 00:05:18,000
final so that no one can change them.

71
00:05:18,000 --> 00:05:24,000
And at the same time we can use these constant values without creating the object of this class.

72
00:05:24,000 --> 00:05:31,000
And here you can also see I'm mentioning a private constructor with this private constructor.

73
00:05:31,000 --> 00:05:34,000
I don't want anyone creating an object of this class.

74
00:05:34,000 --> 00:05:38,000
The reason is, inside this class I want to maintain only constants.

75
00:05:38,000 --> 00:05:43,000
I don't want someone poluting this class with some methods or any other business logic.

76
00:05:43,000 --> 00:05:49,000
With that reason, I have created a private constructor, which means no one can create an object of

77
00:05:49,000 --> 00:05:50,000
this class.

78
00:05:50,000 --> 00:05:55,000
That's why I should also make sure I'm mentioning this static keyword for all the constants so that

79
00:05:55,000 --> 00:05:59,000
I can invoke them and use them with the help of class name itself.

80
00:05:59,000 --> 00:06:05,000
And whenever we are using static and final, it is a good standard and it is a recommended to use the

81
00:06:05,000 --> 00:06:10,000
field name or constant name completely with the all caps like you can see.

82
00:06:10,000 --> 00:06:14,000
And if you have multiple words inside your field name, just make sure you are separating them with

83
00:06:14,000 --> 00:06:16,000
the help of underscore.

84
00:06:16,000 --> 00:06:20,000
As of now, we have warnings that nowhere we have used these constants.

85
00:06:20,000 --> 00:06:23,000
But don't worry, we are going to use all these constants

86
00:06:23,000 --> 00:06:26,000
then these warnings will get resolved automatically.

87
00:06:26,000 --> 00:06:32,000
Now, coming to the AccountsController here to this response, I want to pass what is a statusCode

88
00:06:32,000 --> 00:06:36,000
and status response that I want to return to my client application.

89
00:06:36,000 --> 00:06:44,000
So using accounts constants, I'm going to invoke the constant which is status_201.

90
00:06:44,000 --> 00:06:51,000
This indicates a record is created successfully and very similarly using accounts constant.

91
00:06:51,000 --> 00:06:56,000
I'm going to invoke the constant of message_201. With this,

92
00:06:56,000 --> 00:07:02,000
whenever an account is created successfully, we are sending a response saying that the resource is

93
00:07:02,000 --> 00:07:04,000
created with the help of this status.

94
00:07:04,000 --> 00:07:08,000
So this status will go in the response header.

95
00:07:08,000 --> 00:07:16,000
And similarly inside the body we can also send status as 201 and a message as account created successfully.

96
00:07:16,000 --> 00:07:21,000
So this is the standard that we need to follow with the help of Response entity.

97
00:07:21,000 --> 00:07:27,000
So Response entity is a class present inside the spring framework using which we can send the overall

98
00:07:27,000 --> 00:07:30,000
status, body and header values inside

99
00:07:30,000 --> 00:07:36,000
my response, you can see there is also a method like contentType(), header() using all these methods of

100
00:07:36,000 --> 00:07:37,000
Response entity.

101
00:07:37,000 --> 00:07:43,000
We can send a lot of information inside the Response to the client applications.

102
00:07:43,000 --> 00:07:49,000
If you send only ResponseDto as a return object instead of Response entity, whatever you have populated

103
00:07:49,000 --> 00:07:55,000
inside the ResponseDto, the same will be sent inside the body of the response, but the client will

104
00:07:55,000 --> 00:07:58,000
never receive what is the overall status?

105
00:07:58,000 --> 00:08:04,000
And similarly, this Response entity also give flexibility to send some header values or any other metadata

106
00:08:04,000 --> 00:08:06,000
information that we want to send.

107
00:08:06,000 --> 00:08:07,000
So I hope this is clear.

108
00:08:07,000 --> 00:08:13,000
Now we need to write the business logic to create the new account inside our H2 database.

109
00:08:13,000 --> 00:08:17,000
So all the business logic we should always write inside the service layer.

110
00:08:17,000 --> 00:08:23,000
The controller layer is only responsible to accept the request and to send the response and to perform

111
00:08:23,000 --> 00:08:25,000
any validations.

112
00:08:25,000 --> 00:08:30,000
That's why let's try to create a service layer with the help of an interface and its implementation.

113
00:08:30,000 --> 00:08:31,000
For the same,

114
00:08:31,000 --> 00:08:35,000
first, I need to create a new package with the name service.

115
00:08:35,000 --> 00:08:42,000
So inside this service package, first I'm going to create a new interface and the interface name is

116
00:08:42,000 --> 00:08:45,000
going to be IAccountsService.

117
00:08:45,000 --> 00:08:47,000
The I indicates interface.

118
00:08:47,000 --> 00:08:51,000
So this is a standard again followed by many projects.

119
00:08:51,000 --> 00:08:55,000
Whenever a class name starts with I, it indicates that it is an interface.

120
00:08:55,000 --> 00:09:00,000
You may ask me a question like then why you didn't follow the same naming standard for the repository

121
00:09:00,000 --> 00:09:04,000
layer, like for the Accounts repository and the Customer repository.

122
00:09:04,000 --> 00:09:08,000
But these repository classes, we never going to have any implementation classes.

123
00:09:08,000 --> 00:09:10,000
So that's why I didn't follow that standard.

124
00:09:10,000 --> 00:09:15,000
Whereas for the I account service, we are going to have an implementation class.

125
00:09:15,000 --> 00:09:22,000
So inside this interface I need to create a method that is responsible to create a new account.

126
00:09:22,000 --> 00:09:26,000
So let me create the method which is void create account.

127
00:09:26,000 --> 00:09:28,000
So this method is not going to return anything.

128
00:09:28,000 --> 00:09:35,000
That's why I'm mentioning the void as a return type was that this method is going to accept the CustomerDto

129
00:09:35,000 --> 00:09:38,000
as an input parameter.

130
00:09:38,000 --> 00:09:41,000
That's why I need to make sure I'm accepting this parameter. On top of this

131
00:09:41,000 --> 00:09:46,000
It is also a good standard to mention that Javadoc method comments.

132
00:09:46,000 --> 00:09:51,000
So you can see I'm just mentioning some method comments saying that that this method is going to accept

133
00:09:51,000 --> 00:09:54,000
a parameter of type CustomerDto object.

134
00:09:54,000 --> 00:09:59,000
And if your method is super, super complex, it is also a good recommendation inside your

135
00:10:00,000 --> 00:10:07,000
projects to write the few details about your method so that if someone joins in future inside your team

136
00:10:07,000 --> 00:10:12,000
and if you left the organization, they will know what is the purpose of this method. 

137
00:10:12,000 --> 00:10:18,000
Right now I'm just going to leave it like this because this method is going to have simple logic. As a next step

138
00:10:18,000 --> 00:10:20,000
inside the same service package.

139
00:10:20,000 --> 00:10:24,000
I'm going to create a new package with the name impl.

140
00:10:24,000 --> 00:10:27,000
So impl means implementation.

141
00:10:27,000 --> 00:10:35,000
Inside this implementation package, I'm going to create a new class with the name AccountServiceImpl.

142
00:10:35,000 --> 00:10:36,000
On top of this class,

143
00:10:36,000 --> 00:10:41,000
First, I need to mention @Service annotation to indicate to spring boot framework that this

144
00:10:41,000 --> 00:10:44,000
class is going to act as a service layer.

145
00:10:44,000 --> 00:10:45,000
So please create a bean.

146
00:10:45,000 --> 00:10:51,000
And once the bean is created by the Springboot framework, I can auto wire this bean to the controller

147
00:10:51,000 --> 00:10:51,000
layer.

148
00:10:51,000 --> 00:10:57,000
So as a next step, we need to make sure that this is implementing a IAccountService interface.

149
00:10:57,000 --> 00:11:04,000
As soon as we add this implement action details, it is asking me to override the abstract method present

150
00:11:04,000 --> 00:11:06,000
inside this IAccountService.

151
00:11:06,000 --> 00:11:13,000
So let me try to click on this implement methods and I'm trying to copy the Javadoc and insert override.

152
00:11:13,000 --> 00:11:14,000
So let me click on this

153
00:11:14,000 --> 00:11:15,000
okay.

154
00:11:15,000 --> 00:11:18,000
With this I have the empty abstract method.

155
00:11:18,000 --> 00:11:25,000
Inside this method we need to write the logic to create a new account. Before I try to write the logic

156
00:11:25,000 --> 00:11:26,000
inside this service class.

157
00:11:26,000 --> 00:11:31,000
First, let me try to autowire the two repository classes that we have created.

158
00:11:31,000 --> 00:11:36,000
That's why I'm trying to mention this AccountRepository and CustomerRepository inside the Service

159
00:11:36,000 --> 00:11:36,000
class.

160
00:11:36,000 --> 00:11:42,000
And on top of this Service class I'm going to mention an annotation which is AllArgsConstructor.

161
00:11:42,000 --> 00:11:48,000
With these, what will happen is behind the scenes my Lombok is going to generate a constructor that

162
00:11:48,000 --> 00:11:52,000
is going to accept all the arguments of this class.

163
00:11:52,000 --> 00:11:57,000
As of now we have only two arguments like AccountsRepository and CustomerRepository.

164
00:11:57,000 --> 00:12:04,000
If I try to see the list of methods, you can see there is a constructor created that accepts two parameters

165
00:12:04,000 --> 00:12:11,000
and whenever there is only a single constructor inside your class that is accepting parameters, you

166
00:12:11,000 --> 00:12:15,000
don't need to manually autowire these repository classes with the help of @Autowire.

167
00:12:15,000 --> 00:12:20,000
The spring framework can automatically do the Autowiring because there is only a single constructor

168
00:12:20,000 --> 00:12:24,000
and the single constructor is going to accept all these parameters.

169
00:12:24,000 --> 00:12:30,000
That's how the autowiring will work automatically in order to save the data into the database

170
00:12:30,000 --> 00:12:36,000
with the help of this repository interfaces, we need to send the object of Customer but not the class.

171
00:12:36,000 --> 00:12:42,000
There should be some mapping logic which will convert the DTO t oentity class and entity class to

172
00:12:42,000 --> 00:12:43,000
DTO.

173
00:12:43,000 --> 00:12:50,000
So that's why I'm going to create a new package here with the name Mapper inside this mapper package.

174
00:12:50,000 --> 00:12:58,000
I'm going to create a new class with the name AccountsMapper and this mapper is going to take care

175
00:12:58,000 --> 00:13:03,000
of mapping DTO to entity and entity to DTO to save some time

176
00:13:03,000 --> 00:13:07,000
I'm just pasting two methods here static methods.

177
00:13:07,000 --> 00:13:09,000
I'll explain you what these methods are doing.

178
00:13:09,000 --> 00:13:11,000
You can also get this code from the GitHub repo.

179
00:13:11,000 --> 00:13:18,000
So if you see here, the very first method will take the first parameter as entity Accounts object and

180
00:13:18,000 --> 00:13:21,000
the second parameter as DTO object.

181
00:13:21,000 --> 00:13:27,000
What this is going to do is it is going to map all the data from Accounts to AccountsDto with the help

182
00:13:27,000 --> 00:13:29,000
of the Setters and Getters methods.

183
00:13:29,000 --> 00:13:36,000
So this simple logic I have written here, it will copy all the account number, account type and branch

184
00:13:36,000 --> 00:13:43,000
address to the DTO and it is going to return that DTO to the method where is trying to invoke this method,

185
00:13:43,000 --> 00:13:47,000
which is mapToAccountDto and this is a static method.

186
00:13:47,000 --> 00:13:49,000
Very similarly, we also have mapToAccounts.

187
00:13:49,000 --> 00:13:56,000
This method is going to do the vice versa, like it is going to accept DTO and accounts and transfer

188
00:13:56,000 --> 00:13:59,000
the data from DTO to entity class.

189
00:13:59,000 --> 00:14:01,000
I hope you are clear with these mapper logic.

190
00:14:01,000 --> 00:14:05,000
Let me create the same for CustomerMapper also.

191
00:14:05,000 --> 00:14:13,000
So whenever you need some mapper between entity and DTO, you need to write such logic inside your projects.

192
00:14:13,000 --> 00:14:19,000
So with the help of this CustomerMapper, I'm going to convert the data from CustomerDto to Customer and

193
00:14:19,000 --> 00:14:20,000
vice versa.

194
00:14:20,000 --> 00:14:23,000
So for the same, I'm going to mention two methods here.

195
00:14:23,000 --> 00:14:25,000
You already know what these methods.

196
00:14:25,000 --> 00:14:27,000
What is the purpose of them?

197
00:14:27,000 --> 00:14:31,000
If needed, please pass the video and try to understand what these methods are doing.

198
00:14:31,000 --> 00:14:37,000
So once we define these mapper logic and here you may have a question like do I need to write these

199
00:14:37,000 --> 00:14:38,000
mapper logic manually?

200
00:14:38,000 --> 00:14:40,000
Is there any automated way of doing this?

201
00:14:40,000 --> 00:14:47,000
Off course we have libraries that supports these automatic mapping between entity and Pojo Class two

202
00:14:47,000 --> 00:14:50,000
such libraries are modelmapper and map struct.

203
00:14:50,000 --> 00:14:58,000
Using these two libraries, you can do the conversion between DTO to entity and entity to DTO by adding

204
00:14:58,000 --> 00:14:59,000
few dependencies and

205
00:14:59,000 --> 00:15:06,000
writing a few lines of code, but I'm not going to use these dependencies in my course.

206
00:15:06,000 --> 00:15:12,000
The reason is these are not officially recommended by the spring framework when you go to the start.spring.io.

207
00:15:12,000 --> 00:15:18,000
If you look for Lombok, you can see there is a dependency that you can add with the help of this website,

208
00:15:18,000 --> 00:15:24,000
which means this is officially recognized by the spring framework, whereas the maps tracked are any

209
00:15:24,000 --> 00:15:32,000
other mapper libraries, they are not officially recognized and I'm sure your client or your architect

210
00:15:32,000 --> 00:15:38,000
or your leads, they may not agree to bring these dependencies into your microservices because these

211
00:15:38,000 --> 00:15:44,000
are open source and we never know if there is some security issues with these libraries.

212
00:15:44,000 --> 00:15:48,000
You can also see these website does not have official certificate as well.

213
00:15:48,000 --> 00:15:50,000
I'm not blaming these libraries.

214
00:15:50,000 --> 00:15:53,000
I'm just saying please be cautious using these libraries.

215
00:15:53,000 --> 00:15:58,000
If your client and if your Project lead is accepting that, please go ahead and use them, learning

216
00:15:58,000 --> 00:16:01,000
them and using them also is super, super easy.

217
00:16:01,000 --> 00:16:03,000
But for now, I'm not going to use them.

218
00:16:03,000 --> 00:16:07,000
I'm going to use the old style like where I have the complete control.

219
00:16:07,000 --> 00:16:12,000
Like think of a scenario where maybe when I want to send this mobile number to one of the client, I

220
00:16:12,000 --> 00:16:17,000
don't want to send the complete mobile number, I only want to send the mobile number by masking it

221
00:16:17,000 --> 00:16:19,000
and displaying only the last four digits.

222
00:16:19,000 --> 00:16:21,000
Such kind of logic or serialization logic.

223
00:16:21,000 --> 00:16:27,000
We can write inside this CustomerMapper where this kind of flexibility you may not have with these

224
00:16:27,000 --> 00:16:28,000
two libraries.

225
00:16:28,000 --> 00:16:29,000
I hope this is clear.

226
00:16:29,000 --> 00:16:32,000
Now, we have discussed a lot inside this lecture.

227
00:16:32,000 --> 00:16:37,000
Let's try to take a break, come back after five minutes, and I'm going to continue this discussion

228
00:16:37,000 --> 00:16:38,000
in the next lecture.

229
00:16:38,000 --> 00:16:39,000
Thank you,

230
00:16:39,000 --> 00:16:39,000
Bye.


1
00:00:00,000 --> 00:00:05,000
Inside this lecture, let's try to talk in detail about observability and monitoring.

2
00:00:05,000 --> 00:00:08,000
First, let's try to understand what is observability.

3
00:00:08,000 --> 00:00:17,000
Observability is the ability to understand the internal state of a system by observing or by understanding

4
00:00:17,000 --> 00:00:18,000
its output.

5
00:00:18,000 --> 00:00:24,000
For example, in the context of microservices, observability can be achieved by collecting and analyzing

6
00:00:24,000 --> 00:00:29,000
data from a variety of sources such as metrics, logs and traces.

7
00:00:29,000 --> 00:00:36,000
Using all these information, we can try to understand how our microservices that are running internally,

8
00:00:36,000 --> 00:00:44,000
how well a particular microservice is processing all the incoming requests or how many errors my microservice

9
00:00:44,000 --> 00:00:45,000
is throwing.

10
00:00:45,000 --> 00:00:51,000
So all such internal information we can try to understand with the concept of observability.

11
00:00:52,000 --> 00:00:54,000
There are three pillars for observability.

12
00:00:54,000 --> 00:00:57,000
The very first one is metrics.

13
00:00:57,000 --> 00:01:01,000
Metrics are quantitative measurements of the health of a system.

14
00:01:01,000 --> 00:01:06,000
They can be used to track things like CPU usage, memory usage and response times.

15
00:01:06,000 --> 00:01:11,000
So using these metrics, we can measure our microservices performance or health.

16
00:01:12,000 --> 00:01:14,000
The next pillar that we have is logs.

17
00:01:14,000 --> 00:01:15,000
So what are logs?

18
00:01:15,000 --> 00:01:19,000
Logs are a record of events that occur inside a system.

19
00:01:19,000 --> 00:01:26,000
We can put log statements inside our method calls, so whenever that particular method is being executed,

20
00:01:26,000 --> 00:01:33,000
my logs will be generated indicating that a particular record of event is executed successfully.

21
00:01:33,000 --> 00:01:40,000
So using these logs we can track things like errors, exceptions and other unexpected events.

22
00:01:40,000 --> 00:01:42,000
We all know how important logs are

23
00:01:42,000 --> 00:01:49,000
while debugging an issue without logs, it is impossible to identify an issue inside the production

24
00:01:49,000 --> 00:01:51,000
environment. After logs

25
00:01:51,000 --> 00:01:54,000
the last pillar of observability is traces.

26
00:01:54,000 --> 00:01:55,000
So what are traces?

27
00:01:55,000 --> 00:02:02,000
Traces are a record of the path that a request takes through a system inside our microservices network.

28
00:02:02,000 --> 00:02:04,000
They can be hundreds of microservices.

29
00:02:04,000 --> 00:02:08,000
A particular request may travel through the multiple microservices.

30
00:02:08,000 --> 00:02:14,000
So to understand what is a path that my request travelled inside the microservice network, we can use

31
00:02:14,000 --> 00:02:17,000
that traces. Using these traces information

32
00:02:17,000 --> 00:02:22,000
we can track the performance of a request at each microservice or at each method.

33
00:02:22,000 --> 00:02:28,000
And with that we should be able to easily identify any performance bottlenecks. By collecting the data

34
00:02:28,000 --> 00:02:35,000
from these three pillars, we can analyze the data and gain a good understanding of the internal state

35
00:02:35,000 --> 00:02:37,000
of our microservices.

36
00:02:37,000 --> 00:02:44,000
This understanding can help developers to identify and troubleshoot problems, and in some times we

37
00:02:44,000 --> 00:02:49,000
can also use this information to identify the bottlenecks and improve the performance.

38
00:02:49,000 --> 00:02:54,000
And apart from performance and troubleshooting problems, with the help of these data, we can also

39
00:02:54,000 --> 00:02:56,000
ensure the overall health of the system.

40
00:02:56,000 --> 00:02:58,000
I hope you are clear what is observability.

41
00:02:58,000 --> 00:03:03,000
Now let's try to understand what is monitoring. Monitoring in microservice

42
00:03:03,000 --> 00:03:11,000
context involves checking the telemetry data available for the application and defining the alerts for

43
00:03:11,000 --> 00:03:12,000
known failure

44
00:03:12,000 --> 00:03:12,000
state.

45
00:03:12,000 --> 00:03:19,000
We saw inside the observability we use the data like logs, metrics and traces for troubleshooting any

46
00:03:19,000 --> 00:03:21,000
defects or performance issues.

47
00:03:21,000 --> 00:03:27,000
But with the help of monitoring, we can build some dashboards and build alerts and notifications based

48
00:03:27,000 --> 00:03:31,000
upon metrics, logs and traces information.

49
00:03:31,000 --> 00:03:37,000
Maybe we can try to build a dashboard which can be used by the operations team to monitor the overall

50
00:03:37,000 --> 00:03:39,000
health of our microservices.

51
00:03:39,000 --> 00:03:46,000
If the CPU utilization of a particular container or a microservice crossed more than 80%, then I want

52
00:03:46,000 --> 00:03:48,000
a alert to be triggered.

53
00:03:48,000 --> 00:03:52,000
So all such scenarios we can achieve with the help of monitoring.

54
00:03:52,000 --> 00:03:59,000
Monitoring is very important inside microservices because it will allow us to identify and troubleshoot

55
00:03:59,000 --> 00:04:00,000
problems.

56
00:04:00,000 --> 00:04:06,000
If you have hundreds of microservices running in different containers, in different virtual machines

57
00:04:06,000 --> 00:04:12,000
monitoring all of them, 24 by seven is going to be super, super impossible task.

58
00:04:12,000 --> 00:04:18,000
That's why by collecting and analyzing the data from the individual microservices, we can identify

59
00:04:18,000 --> 00:04:23,000
problems before they cause any outages or other disruptions.

60
00:04:23,000 --> 00:04:30,000
For example, if you take the same CPU usage example if a particular microservice CPU usage is more

61
00:04:30,000 --> 00:04:37,000
than 80%, then I can try to add one more instance of the microservice so that the traffic will be divided

62
00:04:37,000 --> 00:04:39,000
between these two instances.

63
00:04:39,000 --> 00:04:45,000
So here, using this monitoring information, I'm trying to avoid the outage by adding more number of

64
00:04:45,000 --> 00:04:46,000
instances.

65
00:04:46,000 --> 00:04:53,000
And apart from identifying and troubleshooting problems using monitoring, we can also track the health

66
00:04:53,000 --> 00:05:00,000
of our microservices. Using dashboards, alerts and notifications we can easily understand which

67
00:05:00,000 --> 00:05:07,000
microservice is underperforming or which microservice is having some network problems or any other kind

68
00:05:07,000 --> 00:05:11,000
of problems that will affect the performance of my microservice.

69
00:05:11,000 --> 00:05:17,000
And at last, using monitoring, we can try to optimize our microservices by onboarding more number

70
00:05:17,000 --> 00:05:21,000
of instances or by killing the microservice, which is having problems.

71
00:05:21,000 --> 00:05:26,000
And in the same place we can try to onboard a new container or a new microservice instance.

72
00:05:26,000 --> 00:05:32,000
With all these approaches, we are going to improve the performance and reliability of the microservices.

73
00:05:32,000 --> 00:05:36,000
So here you may have a question like both observability and monitoring

74
00:05:36,000 --> 00:05:41,000
they are looking very similar and you may also have confusion like what is the difference between them?

75
00:05:41,000 --> 00:05:43,000
Let me try to answer the same.

76
00:05:43,000 --> 00:05:48,000
Monitoring and observability can be considered as a two sides of the same coin.

77
00:05:48,000 --> 00:05:54,000
Both rely on the same types of telemetry data to enable insights about your microservices.

78
00:05:54,000 --> 00:06:01,000
These telemetry data or data types, includes metrics, traces, and logs using these kind of information

79
00:06:01,000 --> 00:06:05,000
only both observability and monitoring are going to work.

80
00:06:05,000 --> 00:06:11,000
Let's try to understand in detail what is the difference between monitoring and observability. For the

81
00:06:11,000 --> 00:06:11,000
same,

82
00:06:11,000 --> 00:06:18,000
if you try to take an example of iceberg, whatever you are able to see on the top of the iceberg,

83
00:06:18,000 --> 00:06:25,000
we can call that as monitoring because we will be easily able to see how our microservices health,

84
00:06:25,000 --> 00:06:28,000
what is the CPU usage, how many threads are being used?

85
00:06:28,000 --> 00:06:34,000
All such information we can easily see with the help of monitoring because inside the monitoring we

86
00:06:34,000 --> 00:06:37,000
are going to build the dashboards, alerts and notifications.

87
00:06:37,000 --> 00:06:44,000
But whatever information which you cannot easily see, all such information, we call it as observability,

88
00:06:44,000 --> 00:06:50,000
there might be some NullPointerException inside my microservice network until unless I go and look

89
00:06:50,000 --> 00:06:54,000
into the logs, I cannot really understand where the issue is.

90
00:06:54,000 --> 00:06:58,000
So such kind of information comes under the observability.

91
00:06:58,000 --> 00:07:02,000
Let me give you a table which has differences between monitoring and observability.

92
00:07:02,000 --> 00:07:08,000
Like you can see here, if you take the purpose of monitoring and observability, monitoring is going

93
00:07:08,000 --> 00:07:10,000
to help you to identify and troubleshoot problems.

94
00:07:10,000 --> 00:07:16,000
Whereas with the help of observability, we can try to understand the internal state of a system. Coming

95
00:07:16,000 --> 00:07:17,000
to that

96
00:07:17,000 --> 00:07:24,000
what kind of data that will be used inside the monitoring is metrics, traces and logs inside observability.

97
00:07:24,000 --> 00:07:30,000
Apart from these metrics, trace and logs, other kind of information also will be leveraged.

98
00:07:30,000 --> 00:07:32,000
Moving on to the next information, which is goal.

99
00:07:32,000 --> 00:07:38,000
The goal of the monitoring is to identify the problems, whereas the observability goal is to understand

100
00:07:38,000 --> 00:07:40,000
how a system works.

101
00:07:40,000 --> 00:07:43,000
Now let's talk about the approach. Inside the monitoring

102
00:07:43,000 --> 00:07:45,000
the approach is going to be reactive.

103
00:07:45,000 --> 00:07:47,000
So what is reactive approach?

104
00:07:47,000 --> 00:07:51,000
When I say reactive, we are going to react when a problem occurs.

105
00:07:51,000 --> 00:07:57,000
For example, your operations team can react when a particular microservice is facing some network problems

106
00:07:57,000 --> 00:08:00,000
or some performance issues. Without seeing those events.

107
00:08:00,000 --> 00:08:03,000
Your operations team cannot react to them.

108
00:08:03,000 --> 00:08:09,000
That's why inside the monitoring the approach will always be reactive, whereas inside the observability

109
00:08:10,000 --> 00:08:12,000
the approach is going to be proactive.

110
00:08:12,000 --> 00:08:17,000
For example, your microservice might be throwing some NullPointerExceptions.

111
00:08:17,000 --> 00:08:23,000
Maybe it is not throwing for each and every request for some random scenario or for some rare scenario.

112
00:08:23,000 --> 00:08:27,000
A particular microservice is throwing a RuntimeException or NullPointerException.

113
00:08:27,000 --> 00:08:34,000
So as a developer you will try to proactively identify the issues so that you can provide a fix in the

114
00:08:34,000 --> 00:08:35,000
future release.

115
00:08:35,000 --> 00:08:37,000
So this is a proactive approach.

116
00:08:37,000 --> 00:08:39,000
I hope you are clear what is monitoring and observability.

117
00:08:39,000 --> 00:08:45,000
If you ask me to explain the difference of monitoring and observability in simple words, I would say

118
00:08:45,000 --> 00:08:50,000
monitoring is about collecting data, and observability is about understanding data.

119
00:08:50,000 --> 00:08:57,000
We can also say monitoring is reacting to the problems while observability is fixing them in real time.

120
00:08:57,000 --> 00:09:04,000
Like any runtime exceptions or performance issues, we have to deep dive into the information to understand

121
00:09:04,000 --> 00:09:07,000
the internal state and fix them in real time.

122
00:09:07,000 --> 00:09:11,000
With this, I am assuming you are clear about what is observable and monitoring.

123
00:09:11,000 --> 00:09:12,000
Always,

124
00:09:12,000 --> 00:09:17,000
please note that observability will help you to understand the internal state of a system, whereas

125
00:09:17,000 --> 00:09:24,000
monitoring will help you to identify and troubleshoot problems with the help of alerts, dashboards,

126
00:09:24,000 --> 00:09:25,000
notifications.

127
00:09:25,000 --> 00:09:28,000
Thank you and I'll catch you in the next lecture bye.


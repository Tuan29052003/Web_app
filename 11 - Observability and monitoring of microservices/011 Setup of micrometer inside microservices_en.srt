1
00:00:00,000 --> 00:00:01,000
Inside this lecture,

2
00:00:01,000 --> 00:00:06,000
let's try to implement the changes related to the micrometer inside our microservices.

3
00:00:06,000 --> 00:00:11,000
We as a developer, we don't need to write a lot of business logic or a lot of Java logic.

4
00:00:11,000 --> 00:00:17,000
We just need to simply add the dependency related to Micrometer and Prometheus inside our applications.

5
00:00:17,000 --> 00:00:19,000
And with that we should be good.

6
00:00:19,000 --> 00:00:22,000
So let's try to implement the same inside this lecture. For the same,

7
00:00:22,000 --> 00:00:26,000
first, I'm going to open the pom.xml of accounts microservice.

8
00:00:26,000 --> 00:00:34,000
So inside this pom.xml, just after the actuator dependency, I'm going to create a new dependency with

9
00:00:34,000 --> 00:00:39,000
a group ID as io.micrometer.

10
00:00:39,000 --> 00:00:43,000
After mentioning this group ID, we can also mention the artifact ID.

11
00:00:43,000 --> 00:00:50,000
The artifact ID is going to be micrometer-registry -prometheus.

12
00:00:50,000 --> 00:00:56,000
By simply adding this dependency, we are telling to the micrometer to expose the actuator metrics in

13
00:00:56,000 --> 00:01:00,000
a format that my Prometheus can understand. In  future,

14
00:01:00,000 --> 00:01:05,000
if your organization decides to go with some other monitoring system other than Prometheus, then you

15
00:01:05,000 --> 00:01:09,000
just need to change the artifactId, and with that you should be good.

16
00:01:09,000 --> 00:01:13,000
So let me save this changes and do a maven reload.

17
00:01:13,000 --> 00:01:19,000
I'm going to copy the same dependency and mention the same inside all the pom.xml of other microservices.

18
00:01:19,000 --> 00:01:24,000
I'm going to do this behind the scenes just to save some time. Behind the scenes,

19
00:01:24,000 --> 00:01:27,000
I have added these dependency inside all the microservices.

20
00:01:27,000 --> 00:01:33,000
As a next step, I'm going to introduce one new property inside the application.yml.

21
00:01:33,000 --> 00:01:37,000
So let me go to the accounts application.yml file.

22
00:01:37,000 --> 00:01:44,000
Inside this file I'm going to add a new property under the management and this property is related to

23
00:01:44,000 --> 00:01:45,000
metrics.

24
00:01:45,000 --> 00:01:52,000
So let me paste the same as a child under the management and this property is metrics, tags, application

25
00:01:52,000 --> 00:01:54,000
and what is the application name.

26
00:01:54,000 --> 00:01:59,000
So we're trying to assign a value from the property which is spring.application.name.

27
00:01:59,000 --> 00:02:06,000
If you can scroll up here, we have a property with the same key like spring.application.name with

28
00:02:06,000 --> 00:02:07,000
the value as accounts.

29
00:02:07,000 --> 00:02:11,000
So at the runtime the value accounts will be assigned to these property.

30
00:02:11,000 --> 00:02:16,000
So here you may have a question like what is the purpose of this property?

31
00:02:16,000 --> 00:02:21,000
With the help of this property we are telling to the micrometer and Prometheus, please group all my

32
00:02:21,000 --> 00:02:27,000
metrics related to the accounts microservice under the application name, which is accounts.

33
00:02:27,000 --> 00:02:31,000
This is going to help you to identify the metrics of each of the microservice.

34
00:02:31,000 --> 00:02:36,000
Otherwise you cannot really identify which metrics belongs to which microservice.

35
00:02:36,000 --> 00:02:38,000
So that's the purpose of this property.

36
00:02:38,000 --> 00:02:44,000
Behind the scenes, I'm going to add these property inside the application.yml of all the microservices.

37
00:02:44,000 --> 00:02:49,000
Now I have added this property inside all the microservices.

38
00:02:49,000 --> 00:02:52,000
As a next step I'm going to do a clean build.

39
00:02:52,000 --> 00:02:56,000
Once the build is completed, we can try to start all our microservices.

40
00:02:57,000 --> 00:03:00,000
The very first service that we need to start is config server.

41
00:03:00,000 --> 00:03:03,000
So here I'm trying to start my config server.

42
00:03:03,000 --> 00:03:08,000
Once the config server is started, I'm going to start the Eureka server.

43
00:03:08,000 --> 00:03:10,000
So let me try to start my Eureka server.

44
00:03:10,000 --> 00:03:17,000
And once the Eureka server is started we can start accounts, loans and cards microservice.

45
00:03:17,000 --> 00:03:24,000
So here I'm trying to first start my accounts microservice parallelly I can also try to start cards

46
00:03:24,000 --> 00:03:26,000
microservice as well. After the cards,

47
00:03:26,000 --> 00:03:30,000
microservice I'm going to start my loans microservice.

48
00:03:30,000 --> 00:03:37,000
So let me start my loans microservice by going to the class, which is LoansApplication.

49
00:03:37,000 --> 00:03:44,000
Once all my accounts, cards and LoansApplication started successfully, I can try to start my

50
00:03:44,000 --> 00:03:45,000
GatewayserverApplication.

51
00:03:45,000 --> 00:03:48,000
So here I'm trying to start my GatewayserverApplication.

52
00:03:48,000 --> 00:03:55,000
Now, as a next step, we can try to understand the actuator URLs of all the microservices and see how

53
00:03:55,000 --> 00:03:59,000
the micrometer is exposing the metrics information.

54
00:03:59,000 --> 00:04:01,000
For the same, Let me go to the browser. Inside the browser,

55
00:04:01,000 --> 00:04:07,000
first, I'm going to open the actuator URL of accounts microservice.

56
00:04:07,000 --> 00:04:13,000
My accounts microservice started at the port 8080. After mentioning this base path of actuator.

57
00:04:13,000 --> 00:04:16,000
I'm going to mention the path which is metrics.

58
00:04:16,000 --> 00:04:22,000
So if I try to access this, you should be able to see all the metrics exposed by my actuator.

59
00:04:22,000 --> 00:04:24,000
So there are good amount of metrics.

60
00:04:24,000 --> 00:04:31,000
Suppose if you want to understand a specific metric like maybe CPU usage, you can copy this metric

61
00:04:31,000 --> 00:04:40,000
and mention the same inside the URL, which is localhost 8080 followed by actuator, followed by metrics.

62
00:04:40,000 --> 00:04:42,000
After metrics we can mention what is the metric name.

63
00:04:42,000 --> 00:04:49,000
So you can see I am getting the details about a metrics which is CPU usage of accounts microservice.

64
00:04:49,000 --> 00:04:51,000
So this is a value.

65
00:04:51,000 --> 00:04:53,000
As of now, the CPU usage is 0.0.

66
00:04:53,000 --> 00:04:59,000
Very similarly, if I try to understand process uptime, I can go and mention the same inside url

67
00:04:59,000 --> 00:05:04,000
after the Matrix and it will give the what is the process of time?

68
00:05:04,000 --> 00:05:11,000
Like my accounts microservice is up and running without any issues from last one 72 seconds.

69
00:05:11,000 --> 00:05:13,000
If I try to refresh the number will change.

70
00:05:13,000 --> 00:05:13,000
This way

71
00:05:13,000 --> 00:05:19,000
we can also try to understand each of the metric of each microservice instance.

72
00:05:19,000 --> 00:05:26,000
Do you think it is going to be feasible for me to look all these metrics manually by using the port

73
00:05:26,000 --> 00:05:28,000
number of all the microservices instances.

74
00:05:28,000 --> 00:05:30,000
It is not going to be feasible option.

75
00:05:30,000 --> 00:05:35,000
That's why we are going to expose all these metrics information to Prometheus.

76
00:05:35,000 --> 00:05:42,000
So when we add the dependency related to Micrometer and Prometheus inside our microservice, the micrometer

77
00:05:42,000 --> 00:05:49,000
is going to expose a URL which is /actuator/prometheus.

78
00:05:49,000 --> 00:05:53,000
So let me invoke this Prometheus URL.

79
00:05:53,000 --> 00:05:59,000
So you can see here these are all the metrics, information which are present inside a format that that

80
00:05:59,000 --> 00:06:00,000
my Prometheus can understand.

81
00:06:00,000 --> 00:06:02,000
So there is lot of information here.

82
00:06:02,000 --> 00:06:11,000
So my Prometheus is going to invoke this API path for every five seconds or every 10s or every one minute

83
00:06:11,000 --> 00:06:14,000
based upon your configurations inside the Prometheus.

84
00:06:14,000 --> 00:06:19,000
Similarly, it is also going to invoke the same path against all the microservice instances.

85
00:06:19,000 --> 00:06:23,000
So let's go and validate other microservice URLs as well.

86
00:06:23,000 --> 00:06:27,000
So 8090 I'm trying to invoke this confirms for loans

87
00:06:27,000 --> 00:06:28,000
also it is working.

88
00:06:28,000 --> 00:06:32,000
Now I'll go and try to invoke for cards at the port 9000.

89
00:06:32,000 --> 00:06:34,000
So for cards also it is working.

90
00:06:34,000 --> 00:06:41,000
Let me do the same for port number 8070 and at 8070 we have Eureka Server.

91
00:06:41,000 --> 00:06:43,000
So it is also working fine.

92
00:06:43,000 --> 00:06:50,000
Now I'll try to invoke 8071 where we have deployed our config server and at last I'm going to invoke

93
00:06:50,000 --> 00:06:57,000
8072 port as well where we have Gatewayserver running. With this all our microservices

94
00:06:57,000 --> 00:07:04,000
now they are exposing the actuator metrics in a format that can be understand by the Prometheus with

95
00:07:04,000 --> 00:07:06,000
the help of micrometer.

96
00:07:06,000 --> 00:07:08,000
I hope you are clear with the changes.

97
00:07:08,000 --> 00:07:11,000
Thank you and I'll catch you in the next lecture bye.


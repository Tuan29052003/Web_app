1
00:00:00,000 --> 00:00:06,000
As of now, we discussed about one of the pillar of observability and monitoring, which is logging.

2
00:00:06,000 --> 00:00:07,000
Inside this lecture,

3
00:00:07,000 --> 00:00:13,000
let me give you a quick introduction about the second pillar of observability and monitoring, which

4
00:00:13,000 --> 00:00:14,000
is metrics.

5
00:00:14,000 --> 00:00:18,000
Do you think by using logs alone, we can monitor our applications?

6
00:00:18,000 --> 00:00:24,000
Off course not, because with the help of event logs, we can only try to understand what happened under

7
00:00:24,000 --> 00:00:27,000
a specific scenario or under a specific method.

8
00:00:27,000 --> 00:00:32,000
With the help of the logs, we can't understand what is the overall health of my accounts microservice

9
00:00:32,000 --> 00:00:34,000
or any other microservice.

10
00:00:34,000 --> 00:00:40,000
So to properly monitor our microservices, we need to understand metrics details like what is the

11
00:00:40,000 --> 00:00:46,000
CPU usage, what is the memory usage, what is the heap dump usage, what are the threads, connections,

12
00:00:46,000 --> 00:00:46,000
errors.

13
00:00:46,000 --> 00:00:51,000
So there are many metrics that are available to properly monitor our applications.

14
00:00:51,000 --> 00:00:57,000
So that's why we need to make sure we are also collecting the metrics and using the same metrics.

15
00:00:57,000 --> 00:01:03,000
We need to build the dashboards so that operations team, they can always monitor our microservices.

16
00:01:03,000 --> 00:01:10,000
Like we discussed before, matrixs represents numerical measurements of an application performance.

17
00:01:10,000 --> 00:01:16,000
So these metrics we need to collect and aggregate at regular intervals so that we can use them to monitor

18
00:01:16,000 --> 00:01:18,000
the applications health and performance.

19
00:01:18,000 --> 00:01:24,000
And if needed, we can set alerts or notifications when a specific threshold is exceeded.

20
00:01:24,000 --> 00:01:30,000
So how to achieve this with the help of components like Spring Boot Actuator, Micrometer, Prometheus

21
00:01:30,000 --> 00:01:31,000
and Grafana?

22
00:01:31,000 --> 00:01:36,000
So let's try to understand what is the role played by each of these components.

23
00:01:36,000 --> 00:01:42,000
The very first component that is responsible to generate the metrics inside a microservice instance

24
00:01:42,000 --> 00:01:44,000
is spring boot actuator.

25
00:01:44,000 --> 00:01:50,000
As of now, we have added spring boot actuator in all the microservices.

26
00:01:50,000 --> 00:01:56,000
So whenever we add this dependency inside our spring boot microservice, my spring boot actuator is

27
00:01:56,000 --> 00:01:59,000
going to expose all the metrics related to the application.

28
00:01:59,000 --> 00:02:00,000
The same

29
00:02:00,000 --> 00:02:06,000
we can also try to understand by navigating to the path which is /actuator/metrics and this

30
00:02:06,000 --> 00:02:13,000
metrics actuator path, there will be many metrics that can help you to monitor your microservice instance.

31
00:02:13,000 --> 00:02:19,000
These metrics that are exposed by the actuator is going to help you to monitor your microservice instance.

32
00:02:19,000 --> 00:02:27,000
But do you think it is a feasible option for me to navigate to all the actuator URLs of all my microservice

33
00:02:27,000 --> 00:02:31,000
instances every time to understand the overall health of a particular microservice instance?

34
00:02:31,000 --> 00:02:34,000
Off course that is going to be a super, super tedious job.

35
00:02:34,000 --> 00:02:41,000
If I have 100 different microservices running with different number of instances navigating each of

36
00:02:41,000 --> 00:02:45,000
these instance actuator is going to be super, super tedious job.

37
00:02:45,000 --> 00:02:51,000
That's why we need to make sure there is a component which is responsible to extract and aggregate all

38
00:02:51,000 --> 00:02:54,000
the metrics from the microservices

39
00:02:54,000 --> 00:02:57,000
instances running inside my Microservice network.

40
00:02:57,000 --> 00:03:00,000
We have such component already inside the open source.

41
00:03:00,000 --> 00:03:08,000
The component is Prometheus, but the Prometheus cannot understand the metrics provided by the actuator

42
00:03:08,000 --> 00:03:15,000
because actuator exposes the metrics information in a Json format which we can easily understand as

43
00:03:15,000 --> 00:03:21,000
humans, since the same format cannot be understand by the Prometheus, we need to use micrometer.

44
00:03:21,000 --> 00:03:24,000
So what is the purpose of this micrometer?

45
00:03:24,000 --> 00:03:31,000
Micrometer automatically exposes the actuator/metricsdata into a format that a particular monitoring

46
00:03:31,000 --> 00:03:32,000
system can understand.

47
00:03:32,000 --> 00:03:40,000
We, as a developer, we need to simply add the vendor specific micrometer dependency inside the application

48
00:03:40,000 --> 00:03:43,000
and post that the micrometer is going to take care of

49
00:03:43,000 --> 00:03:48,000
exposing the metrics information in a format that you are monitoring system can understand.

50
00:03:48,000 --> 00:03:55,000
So here, since we decided to use Prometheus, we need to add the dependency related to micrometer and

51
00:03:55,000 --> 00:03:55,000
Prometheus.

52
00:03:55,000 --> 00:04:02,000
And micrometer is going to take care of exposing all your metrics in a format that Prometheus can understand.

53
00:04:02,000 --> 00:04:10,000
So this micrometer is very similar to SLF4J, but SLF4J is a fact pattern which will help

54
00:04:10,000 --> 00:04:13,000
us in implementing a lot of other logging frameworks.

55
00:04:13,000 --> 00:04:19,000
Just like SLF4J for logging, we can assume micrometer is for the metrics.

56
00:04:19,000 --> 00:04:21,000
So this is the website of micrometer.

57
00:04:21,000 --> 00:04:25,000
You can see it is going to act as a vendor neutral application observability facade.

58
00:04:25,000 --> 00:04:26,000
So what is a facade ?

59
00:04:26,000 --> 00:04:29,000
We have a design pattern with the name fact design pattern.

60
00:04:29,000 --> 00:04:31,000
So what is the purpose of fact design pattern?

61
00:04:31,000 --> 00:04:39,000
It is going to deploy a front facing interface that will handle a lot of complexity behind the scenes.

62
00:04:39,000 --> 00:04:44,000
We as a client, we can simply use this front  facing interface to make our life easy.

63
00:04:44,000 --> 00:04:51,000
So behind the scenes, this observability can expose the metrics based upon different, different vendors.

64
00:04:51,000 --> 00:04:53,000
One such vendor is Prometheus.

65
00:04:53,000 --> 00:05:00,000
If you can scroll down, it is going to support many other vendors like App Optics, Azure Monitor,

66
00:05:00,000 --> 00:05:00,000
Cloudwatch,

67
00:05:00,000 --> 00:05:02,000
Datadog, Dynatrace,

68
00:05:02,000 --> 00:05:06,000
Elastic, Graphite, Opentelemetry, Prometheus.

69
00:05:06,000 --> 00:05:09,000
So behind the scenes it is going to support all these vendors.

70
00:05:09,000 --> 00:05:16,000
As a developer, I don't need to worry how my micrometer is going to expose that metrics information

71
00:05:16,000 --> 00:05:17,000
based upon the product I choose.

72
00:05:17,000 --> 00:05:23,000
We simply need to add the dependency of micrometer that is specific to a vendor and behind the scenes

73
00:05:23,000 --> 00:05:26,000
micrometer is going to do a lot of job for you.

74
00:05:26,000 --> 00:05:29,000
So this is very similar to SLF4J.  What is SLF4J ?.

75
00:05:29,000 --> 00:05:34,000
The expansion of SLF4J is, Simple Logging Framework for Java.

76
00:05:34,000 --> 00:05:39,000
So inside Java there are many logging frameworks like with the help of Java util logging, we can do

77
00:05:40,000 --> 00:05:43,000
logging and very similarly we have log forge, log back.

78
00:05:43,000 --> 00:05:49,000
There are many logging frameworks and sometimes we as a developer, if we want to use many logging framework

79
00:05:49,000 --> 00:05:53,000
inside our application, we don't need to handle all such complexity.

80
00:05:53,000 --> 00:05:59,000
Instead, we can simply use the SLF4J which is going to act as a backend for all your logging

81
00:05:59,000 --> 00:06:00,000
frameworks.

82
00:06:00,000 --> 00:06:06,000
With the help of SLF4J, we can easily implement any kind of logging frameworks inside your web

83
00:06:06,000 --> 00:06:10,000
application without worrying about the complexities involved.

84
00:06:10,000 --> 00:06:12,000
I hope you are clear about what is micrometer.

85
00:06:12,000 --> 00:06:20,000
Once my micrometer exposes the metric information, my Prometheus is going to regularly export that

86
00:06:20,000 --> 00:06:27,000
metrics information from my individual microservice containers using the same metrics that my Prometheus

87
00:06:27,000 --> 00:06:28,000
exported,

88
00:06:28,000 --> 00:06:31,000
it is going to consolidate all of them into a single place.

89
00:06:31,000 --> 00:06:33,000
So this is very similar to Loki.

90
00:06:33,000 --> 00:06:35,000
So what is the job of Loki?

91
00:06:35,000 --> 00:06:40,000
With the help of Loki, we are trying to aggregate the logs, whereas with the help of Prometheus we

92
00:06:40,000 --> 00:06:45,000
are going to aggregate the metrics of all your containers and microservices.

93
00:06:45,000 --> 00:06:48,000
So let's try to understand more details about Prometheus.

94
00:06:48,000 --> 00:06:55,000
Prometheus is an open source product which is going to help you to collect all the metrics from the

95
00:06:55,000 --> 00:06:57,000
respective containers and microservices.

96
00:06:57,000 --> 00:07:04,000
We can also try to build the dashboards, graphs, which will help us to monitor our microservices.

97
00:07:04,000 --> 00:07:07,000
So it is a open source monitoring solution.

98
00:07:07,000 --> 00:07:13,000
I'm going to show you a demo of Prometheus in the coming lectures, but for now, please note that Prometheus

99
00:07:13,000 --> 00:07:18,000
is going to collect the metrics from the individual microservice and it is going to store all of them

100
00:07:18,000 --> 00:07:24,000
in a single location, which we can monitor easily with the help of UI provided by the Prometheus.

101
00:07:24,000 --> 00:07:28,000
After the Prometheus, we should also integrate Prometheus with the Grafana.

102
00:07:28,000 --> 00:07:34,000
Here you may have a question like what is the need of Grafana when we already have Prometheus which

103
00:07:34,000 --> 00:07:37,000
will help us to monitor our microservices?

104
00:07:37,000 --> 00:07:41,000
I agree with you, but Prometheus has certain limitations.

105
00:07:41,000 --> 00:07:47,000
We cannot build very complex dashboards and we cannot create alerts and notifications with the Prometheus

106
00:07:47,000 --> 00:07:47,000
alone.

107
00:07:47,000 --> 00:07:54,000
When we integrate Prometheus with Grafana, we can build a lot of dashboards and apart from dashboards

108
00:07:54,000 --> 00:07:57,000
we can also create alerts and notifications.

109
00:07:57,000 --> 00:08:03,000
That's why we need to make sure we are integrating Prometheus with the Grafana. Just like how we integrated

110
00:08:03,000 --> 00:08:04,000
Loki with the Grafana.

111
00:08:04,000 --> 00:08:09,000
Very similarly, we are going to integrate Prometheus with Grafana and using the metrics present inside

112
00:08:09,000 --> 00:08:12,000
the Prometheus, we are going to build the dashboard.

113
00:08:12,000 --> 00:08:13,000
I hope you are clear.

114
00:08:13,000 --> 00:08:19,000
Like what is the role played by each of these components like Actuator, micrometer, Prometheus and

115
00:08:19,000 --> 00:08:19,000
Grafana?

116
00:08:19,000 --> 00:08:26,000
Let's try to implement these components inside our microservices and see how these components are going

117
00:08:26,000 --> 00:08:29,000
to help us to monitor our applications.

118
00:08:29,000 --> 00:08:31,000
Thank you and I'll catch you in the next lecture bye.


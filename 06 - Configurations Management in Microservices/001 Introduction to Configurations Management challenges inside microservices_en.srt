1
00:00:00,000 --> 00:00:02,000
Welcome back to the new section.

2
00:00:02,000 --> 00:00:06,000
Inside this section we are going to discuss about the challenge 4

3
00:00:06,000 --> 00:00:11,000
that, we are going to face while building the microservice or cloud native applications.

4
00:00:11,000 --> 00:00:16,000
I'm assuming you are liking this approach where we are trying to first discuss what is the challenge

5
00:00:16,000 --> 00:00:21,000
that we are going to face, what are the options that we have and post that selecting a best option.

6
00:00:21,000 --> 00:00:26,000
And the same we are trying to implement inside the microservices like accounts, loans and cards.

7
00:00:26,000 --> 00:00:29,000
Just a reminder, we are into the new section

8
00:00:29,000 --> 00:00:34,000
that's why I have changed the background of the slide just to keep you engaged inside this course.

9
00:00:34,000 --> 00:00:38,000
So what is this new challenge that we may face while building microservices?

10
00:00:38,000 --> 00:00:44,000
This challenge is about configuration management inside the microservices.

11
00:00:44,000 --> 00:00:48,000
So to understand more about this challenge, let me try to pose some questions to you.

12
00:00:48,000 --> 00:00:54,000
The very first question that I have for you is, inside microservices, how we are going to separate the

13
00:00:54,000 --> 00:01:00,000
configurations or properties from your business logic, because without separating the configurations

14
00:01:00,000 --> 00:01:06,000
and properties from your microservices business logic, you cannot reuse the same Docker image across

15
00:01:06,000 --> 00:01:08,000
multiple environments.

16
00:01:08,000 --> 00:01:14,000
If you club all your business logic and configurations together, then for each environment you need

17
00:01:14,000 --> 00:01:20,000
to create a separate Docker image along with the relevant properties or configurations.

18
00:01:20,000 --> 00:01:26,000
Since it is not a recommended approach like generating the Docker image again and again for each environment,

19
00:01:26,000 --> 00:01:32,000
we need to make sure we are using the same Docker image for all type of environments, including the

20
00:01:32,000 --> 00:01:32,000
production.

21
00:01:32,000 --> 00:01:38,000
With such requirements, how are we going to separate the configurations from the business logic?

22
00:01:38,000 --> 00:01:44,000
So this is the very first question that I have, in the similar lines how we are going to inject the configurations

23
00:01:44,000 --> 00:01:50,000
or properties at runtime that are needed by our microservices during the startup of the service, some

24
00:01:50,000 --> 00:01:57,000
of the sensitive properties like credentials, we can't mention them inside any configurations or inside

25
00:01:57,000 --> 00:02:02,000
any business logic, such sensitive properties or configurations.

26
00:02:02,000 --> 00:02:07,000
We need to make sure we are injecting them into microservices during the startup of the service.

27
00:02:07,000 --> 00:02:12,000
In the very similar lines, whenever we are dealing with the configurations or properties, we need

28
00:02:12,000 --> 00:02:18,000
to make sure we are maintaining all these configurations or properties in a centralized repository along

29
00:02:18,000 --> 00:02:20,000
with the versioning of them.

30
00:02:20,000 --> 00:02:25,000
Because inside monolithic applications you will be having only 1 or 2 applications and it is very easy

31
00:02:25,000 --> 00:02:31,000
to maintain all your configurations wherever you want, whereas with hundreds of microservices it is

32
00:02:31,000 --> 00:02:37,000
going to be super complex to maintain all the properties of all the microservices manually.

33
00:02:37,000 --> 00:02:42,000
That's why when we are trying to build microservices, we need to make sure we are maintaining all the

34
00:02:42,000 --> 00:02:46,000
properties in a centralized repository along with the versioning of them.

35
00:02:46,000 --> 00:02:48,000
So how we are going to achieve that?

36
00:02:48,000 --> 00:02:54,000
So we have all these challenges in terms of configuration management in microservices.

37
00:02:54,000 --> 00:03:00,000
I will reveal the options that we have to overcome these challenges, for the configuration management in microservices,

38
00:03:00,000 --> 00:03:06,000
we have multiple solutions available inside the springboot ecosystem, and these solutions are like

39
00:03:06,000 --> 00:03:12,000
right from very basic solution, which is configuring Spring Boot itself with the relevant properties

40
00:03:12,000 --> 00:03:13,000
and the required profiles.

41
00:03:13,000 --> 00:03:18,000
And the second approach is applying external configuration with the spring boot.

42
00:03:18,000 --> 00:03:24,000
And the third approach is implementing a separate configuration server with the spring cloud config

43
00:03:24,000 --> 00:03:25,000
server project.

44
00:03:25,000 --> 00:03:27,000
So these are the options that we have.

45
00:03:27,000 --> 00:03:33,000
I'm going to show a demo of all these options and in the same process I will show what are the basic

46
00:03:33,000 --> 00:03:38,000
approaches and what are the disadvantages that we have with them and what is the best option that we

47
00:03:38,000 --> 00:03:40,000
have and why we should go with that.

48
00:03:40,000 --> 00:03:45,000
So all those discussions I'm going to do inside this section and inside this section, we are going

49
00:03:45,000 --> 00:03:48,000
to make lot of code changes inside our microservices.

50
00:03:48,000 --> 00:03:52,000
So it is going to be super, super engaging and fun throughout this section.

51
00:03:52,000 --> 00:03:59,000
Now, before I try to close this lecture, let me try to give you how the configuration management happens

52
00:03:59,000 --> 00:04:03,000
inside a traditional application and microservices application.

53
00:04:03,000 --> 00:04:09,000
Back in the days when we were trying to build traditional applications or monolithic applications, all your

54
00:04:09,000 --> 00:04:14,000
source code along with the configurations files, they will be bundled together.

55
00:04:14,000 --> 00:04:19,000
And with that, whenever there is a different configuration is needed for a different environment.

56
00:04:19,000 --> 00:04:24,000
We need to rebuild the application code again with the required configurations.

57
00:04:24,000 --> 00:04:30,000
So with this there is no guarantee that the application would behave consistently because the main business

58
00:04:30,000 --> 00:04:36,000
logic may differ from one environment to other environment when you are trying to build the application.

59
00:04:36,000 --> 00:04:41,000
This approach might have worked for monolithic application because there is only one application and they

60
00:04:41,000 --> 00:04:45,000
can do multiple builds based upon the environment.

61
00:04:45,000 --> 00:04:51,000
Whereas with microservice, since there will be hundreds of microservices doing multiple builds again

62
00:04:51,000 --> 00:04:57,000
and again for each environment with the required configuration data is going to be super, super complex.

63
00:04:57,000 --> 00:05:00,000
That's why as per the 15 factor methodology.

64
00:05:00,000 --> 00:05:07,000
All the configurations which are going to change between deployments such as credentials, service URLs

65
00:05:07,000 --> 00:05:08,000
or resource handles.

66
00:05:08,000 --> 00:05:15,000
So all such configuration data we need to provide outside our build component.

67
00:05:15,000 --> 00:05:22,000
So all such configurations that are likely to change, we need to maintain outside our business logic.

68
00:05:22,000 --> 00:05:28,000
So that the application artifacts will be immutable across all environments.

69
00:05:28,000 --> 00:05:34,000
Once we do a build and generate a Docker image for your microservice, the same image you can use across

70
00:05:34,000 --> 00:05:40,000
environments and the configurations has to be injected from the external location.

71
00:05:40,000 --> 00:05:47,000
This way the application build will remains unchanged across all the environments. Like you can see here,

72
00:05:47,000 --> 00:05:52,000
first there will be an microservice or cloud native application codebase inside the GitHub repo.

73
00:05:52,000 --> 00:05:59,000
We will do compilation and package as a build, which is going to be common for all environments.

74
00:05:59,000 --> 00:06:05,000
So inside this build you may generate a Docker image for your microservice and to this build a component

75
00:06:05,000 --> 00:06:10,000
we are going to inject configurations based upon the target environment.

76
00:06:10,000 --> 00:06:16,000
If you are trying to do a deployment into a development environment, then we can inject the configurations

77
00:06:16,000 --> 00:06:22,000
related to that development environment at runtime during the startup of the microservice.

78
00:06:22,000 --> 00:06:28,000
And both your configurations and the source code will be clubbed and deployed into that target environment

79
00:06:28,000 --> 00:06:31,000
like development QA and production.

80
00:06:31,000 --> 00:06:37,000
So this is how it has to work inside microservices or inside the cloud native applications and we should

81
00:06:37,000 --> 00:06:39,000
not follow the traditional approaches.

82
00:06:39,000 --> 00:06:44,000
I hope you are clear with the challenge for and what is the agenda of this section?

83
00:06:44,000 --> 00:06:49,000
So let's try to deep dive into the options that we have to solve the challenge of configuration management

84
00:06:49,000 --> 00:06:51,000
in microservices.

85
00:06:51,000 --> 00:06:53,000
Thank you and I'll catch you in the next lecture bye.


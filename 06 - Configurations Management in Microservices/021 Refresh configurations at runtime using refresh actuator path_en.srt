1
00:00:00,000 --> 00:00:05,000
As of now, inside our microservices network, we have three different microservices and there is a

2
00:00:05,000 --> 00:00:11,000
config server and we are able to read the properties from the config server during the startup of the

3
00:00:11,000 --> 00:00:13,000
microservices applications.

4
00:00:13,000 --> 00:00:19,000
So everything is working perfectly and you may think this is the end of the spring cloud config server

5
00:00:19,000 --> 00:00:24,000
and we may not face any other challenges in terms of configuration management.

6
00:00:24,000 --> 00:00:30,000
But inside this lecture I want to introduce a new problem that we may face inside the microservices

7
00:00:30,000 --> 00:00:33,000
environment in terms of configuration management.

8
00:00:33,000 --> 00:00:40,000
Think like you have your config server setup and all your microservices started by connecting to the

9
00:00:40,000 --> 00:00:40,000
config server

10
00:00:40,000 --> 00:00:42,000
they loaded the properties perfectly.

11
00:00:42,000 --> 00:00:48,000
All of a sudden you want to change a particular property inside your config server and the same you

12
00:00:48,000 --> 00:00:53,000
want to be reflected runtime without restarting your microservices.

13
00:00:53,000 --> 00:00:58,000
Here you may have a question, what is the problem that I have if I restart my microservices. Inside microservice

14
00:00:58,000 --> 00:01:00,000
It's not one microservice

15
00:01:00,000 --> 00:01:05,000
there are hundreds of microservices and there will be multiple instance for each microservice.

16
00:01:05,000 --> 00:01:12,000
So restarting your instances of microservices is again a manual task that someone has to take care.

17
00:01:12,000 --> 00:01:18,000
Whenever you bring some manual task inside microservice, then it is going to make your microservices

18
00:01:18,000 --> 00:01:19,000
setup very complex.

19
00:01:19,000 --> 00:01:26,000
That's why we should look for an option on refreshing the properties without restarting the microservices

20
00:01:26,000 --> 00:01:27,000
instances.

21
00:01:27,000 --> 00:01:32,000
For example, think like you have a feature flag which you have configured inside the config server.

22
00:01:32,000 --> 00:01:39,000
So based upon a feature flag like a boolean flag, you want to control the behavior of your microservice

23
00:01:39,000 --> 00:01:40,000
business logic.

24
00:01:40,000 --> 00:01:44,000
When the flag is disabled, you want to execute some other piece of code.

25
00:01:44,000 --> 00:01:48,000
These flags you want to change anytime inside the config server and you want the same to be reflected

26
00:01:48,000 --> 00:01:52,000
immediately inside your individual microservices without restart.

27
00:01:52,000 --> 00:01:58,000
So this is the most common scenario that projects will try to achieve inside their microservices network.

28
00:01:58,000 --> 00:02:03,000
That's why inside this lecture, let's try to focus on how to refresh the configurations or properties

29
00:02:03,000 --> 00:02:08,000
inside the microservices without restarting the instances. 

30
00:02:08,000 --> 00:02:14,000
For the same, first we need to make sure all our individual microservices, they have the spring boot actuator dependency

31
00:02:14,000 --> 00:02:16,000
defined inside the pom.xml.

32
00:02:16,000 --> 00:02:23,000
So if you can go to the pom.xml of cards microservice and search for actuator, you can see there is

33
00:02:23,000 --> 00:02:26,000
a spring boot starter actuator already added the same

34
00:02:26,000 --> 00:02:30,000
we have added long back inside the loans and accounts microservice as well.

35
00:02:30,000 --> 00:02:35,000
So we have the actuator dependency inside our microservices instances.

36
00:02:35,000 --> 00:02:42,000
As a next step, we need to go to our Dto classes where we are trying to hold all our property details.

37
00:02:42,000 --> 00:02:44,000
So here we have inside accounts microservice

38
00:02:44,000 --> 00:02:50,000
there is a record class with the name AccountsContactInfo which holds all the properties that my

39
00:02:50,000 --> 00:02:54,000
microservice is going to read during the startup from the config server.

40
00:02:54,000 --> 00:02:58,000
With this setup we have a problem whenever we are using a record class,

41
00:02:58,000 --> 00:03:04,000
that means once the object of this AccountContactInfoDto is created during the startup.

42
00:03:04,000 --> 00:03:09,000
We cannot change the property values at runtime by invoking the setter method.

43
00:03:09,000 --> 00:03:13,000
Whenever you are using record class, all your fields are going to be final.

44
00:03:13,000 --> 00:03:18,000
Once object is created with the help of constructor, then there is no way to change the values inside

45
00:03:18,000 --> 00:03:18,000
the fields.

46
00:03:18,000 --> 00:03:20,000
That's why we need to switch these

47
00:03:20,000 --> 00:03:24,000
AccountsContactInfo to a normal class instead of record class.

48
00:03:24,000 --> 00:03:28,000
So let me remove the record and mention the class.

49
00:03:28,000 --> 00:03:34,000
After that we need to remove these syntaxes like we don't need to mention the fields inside these brackets.

50
00:03:34,000 --> 00:03:39,000
So I'm removing that now inside my class, I'm going to define all the fields.

51
00:03:39,000 --> 00:03:42,000
The very first one is private String message.

52
00:03:42,000 --> 00:03:48,000
Once I have defined this, I'm going to mention semicolon post that I'll mention private Map contactDetails,

53
00:03:48,000 --> 00:03:55,000
I'll mention the semicolon at the end and similarly I'll mention private before the List field,

54
00:03:55,000 --> 00:03:56,000
which is onCallSupport.

55
00:03:56,000 --> 00:04:02,000
So now we have the three different fields inside our class. As a next step, we need to mention

56
00:04:02,000 --> 00:04:06,000
@Getter annotation and @Setter annotation.

57
00:04:06,000 --> 00:04:10,000
So these are the annotations from Lombok using these annotations.

58
00:04:10,000 --> 00:04:15,000
Only my spring boot framework is going to get the fields and set the fields at runtime.

59
00:04:15,000 --> 00:04:21,000
Let me do the similar changes inside the LoansContactInfoDto also.

60
00:04:21,000 --> 00:04:23,000
So let me search for 

61
00:04:23,000 --> 00:04:28,000
LoansContactInfoDto. Here I'm going to remove this record and change this to class. Post that

62
00:04:28,000 --> 00:04:32,000
I'm going to remove all these fields and remove these brackets

63
00:04:32,000 --> 00:04:38,000
after this, I'm going to get these fields from the AccountsInfoDto since we are going to maintain

64
00:04:38,000 --> 00:04:39,000
the same set of fields here

65
00:04:39,000 --> 00:04:46,000
also, this should work properly without any issues as an exchange like you know, I need to mention

66
00:04:46,000 --> 00:04:50,000
@Getter annotation followed by @Setter annotation.

67
00:04:50,000 --> 00:04:52,000
So let me do the same for 

68
00:04:52,000 --> 00:04:54,000
CardsContactInfoDto also.

69
00:04:54,000 --> 00:04:59,000
So first I'll mention the Lombok annotations post that I'll change this record to class

70
00:04:59,000 --> 00:05:05,000
followed by I'll remove all these fields along with the brackets and I'll get the field names from the

71
00:05:05,000 --> 00:05:07,000
other classes that we have.

72
00:05:07,000 --> 00:05:10,000
And I'm going to mention the same under the CardsContactInfoDto.

73
00:05:11,000 --> 00:05:15,000
So we have made these Dto related changes in all the microservices.

74
00:05:15,000 --> 00:05:20,000
So this will allow our microservices to change the property values at runtime.

75
00:05:20,000 --> 00:05:27,000
After making these changes, I need to go to my application.yml of Accounts Microservice.

76
00:05:27,000 --> 00:05:28,000
Inside this application.yml,

77
00:05:28,000 --> 00:05:32,000
we need to enable the actuator API paths by default

78
00:05:32,000 --> 00:05:38,000
actuator is not going to expose all the management related API paths.

79
00:05:38,000 --> 00:05:43,000
That's why we need to specifically enable them by introducing a property here.

80
00:05:43,000 --> 00:05:50,000
So the property that I want to mention here is, management since we want to enable the management related

81
00:05:50,000 --> 00:05:51,000
APIs.

82
00:05:51,000 --> 00:05:57,000
So we need to mention this management at the root location. And at this management I need to mention

83
00:05:57,000 --> 00:06:01,000
end points, under this end points we need to mention web,

84
00:06:01,000 --> 00:06:04,000
after this web we need to mention exposure.

85
00:06:04,000 --> 00:06:11,000
After the exposure we need to mention include once we define this include element inside your property.

86
00:06:11,000 --> 00:06:18,000
We need to enable the actuator endpoint that will allow the refreshing the properties at runtime.

87
00:06:18,000 --> 00:06:21,000
Here instead of mentioning the refresh API alone.

88
00:06:21,000 --> 00:06:27,000
Instead we can mention asterisk value with this asterisk value I'm telling to my spring boot actuator

89
00:06:27,000 --> 00:06:33,000
to enable and expose all management endpoint supported by the spring boot actuator.

90
00:06:33,000 --> 00:06:37,000
And inside these endpoints only we are also going to have refresh related endpoint.

91
00:06:37,000 --> 00:06:42,000
Now we need to make the similar set of change inside loans and cards microservice also.

92
00:06:42,000 --> 00:06:45,000
So let me go to the application.yml

93
00:06:45,000 --> 00:06:51,000
of cards microservice. Under these cards microservice we need to open the application.yml.

94
00:06:51,000 --> 00:06:53,000
Inside the application.yml,

95
00:06:53,000 --> 00:06:55,000
I'm going to introduce the same property.

96
00:06:55,000 --> 00:06:59,000
Let me do the same for loans microservice as well.

97
00:06:59,000 --> 00:07:01,000
Inside the application.yml,

98
00:07:01,000 --> 00:07:04,000
I'm going to mention the same property.

99
00:07:04,000 --> 00:07:11,000
With this we have made all the relevant changes inside our microservices as a next step, let's try to start all

100
00:07:11,000 --> 00:07:18,000
our microservices post that we can try to change a property runtime inside the GitHub repo and see whether

101
00:07:18,000 --> 00:07:22,000
by default it is reflecting inside our individual microservices.

102
00:07:22,000 --> 00:07:25,000
So for the same first let me do a build.

103
00:07:25,000 --> 00:07:31,000
Once the build is completed, I'm going to stop all my applications. After all my applications stopped

104
00:07:31,000 --> 00:07:34,000
first I'm going to start my config server application.

105
00:07:34,000 --> 00:07:41,000
Once my config server is started successfully, I'm going to start my AccountsApplication followed

106
00:07:41,000 --> 00:07:42,000
by CardsApplication.

107
00:07:42,000 --> 00:07:44,000
After the CardsApplication,

108
00:07:44,000 --> 00:07:46,000
I'm also going to start the LoansApplication.

109
00:07:46,000 --> 00:07:47,000
Now

110
00:07:47,000 --> 00:07:51,000
all my microservices instances and config servers started successfully.

111
00:07:51,000 --> 00:07:56,000
As a next step, I will try to change the property values inside the GitHub repo.

112
00:07:57,000 --> 00:07:59,000
As of now you can see for the accounts-prod.yml.

113
00:08:00,000 --> 00:08:02,000
We have the message saying that,

114
00:08:02,000 --> 00:08:07,000
hello, welcome to EazyBank accounts related prod APIs. Here inside this message

115
00:08:07,000 --> 00:08:13,000
I'm going to replace this prod with the production, but before I try to replace that first let me show

116
00:08:13,000 --> 00:08:14,000
you right now our accounts

117
00:08:14,000 --> 00:08:17,000
microservice or other microservice

118
00:08:17,000 --> 00:08:19,000
they'll have the message with the prod value.

119
00:08:19,000 --> 00:08:24,000
So here I'm trying to invoke contact-info API for accounts microservice.

120
00:08:24,000 --> 00:08:27,000
You can see there is a prod APIs here.

121
00:08:27,000 --> 00:08:33,000
Very similarly, if I go to cards and invoke this contact-info here also we are getting prod APIs and

122
00:08:33,000 --> 00:08:35,000
the same I can confirm for loans also.

123
00:08:35,000 --> 00:08:41,000
So for loans also I'm just trying to invoke this contact-info which will have these prod APIs inside

124
00:08:41,000 --> 00:08:42,000
the message.

125
00:08:42,000 --> 00:08:44,000
Now let me go to the GitHub repo,

126
00:08:44,000 --> 00:08:49,000
here I'm going to click on this edit button and replace this prod with production.

127
00:08:49,000 --> 00:08:52,000
So I'll do the same for other microservices

128
00:08:52,000 --> 00:08:52,000
also.

129
00:08:52,000 --> 00:08:56,000
Before that, let me commit this file directly into the GitHub repo.

130
00:08:56,000 --> 00:09:01,000
Once I'm done with this accounts file, I'm going to open the cards related file.

131
00:09:01,000 --> 00:09:05,000
So cards-prod is a file which we need to change here.

132
00:09:05,000 --> 00:09:09,000
So let me click on this edit button and replace this prod with production.

133
00:09:09,000 --> 00:09:15,000
Commit the changes into the GitHub repo post that I'm going to open the loans-prod.yml.

134
00:09:15,000 --> 00:09:21,000
And here also I'm going to click on this edit button, replace this prod with production and commit

135
00:09:21,000 --> 00:09:23,000
the changes into the GitHub repo.

136
00:09:23,000 --> 00:09:27,000
Now first I'll show the config server behavior.

137
00:09:27,000 --> 00:09:32,000
Here I'm trying to invoke the account/prod API which is available inside the config server.

138
00:09:32,000 --> 00:09:37,000
You can see my config server has the latest property value which is production.

139
00:09:37,000 --> 00:09:45,000
This confirms whenever a microservice instance is trying to invoke this API path during the startup,

140
00:09:45,000 --> 00:09:49,000
my config server is not going to rely on the local cache.

141
00:09:49,000 --> 00:09:54,000
It is always going to check with the master copy which is available inside the GitHub repo and it is

142
00:09:54,000 --> 00:09:57,000
going to return the same latest values to the accounts

143
00:09:57,000 --> 00:09:59,000
microservice. The same I can confirm for

144
00:09:59,000 --> 00:10:01,000
loans also.

145
00:10:01,000 --> 00:10:05,000
For loans also we have this production similarly for cards we can confirm.

146
00:10:05,000 --> 00:10:07,000
So for cards also it is working fine.

147
00:10:07,000 --> 00:10:11,000
This means there is no problem in refreshing the properties on the config server.

148
00:10:12,000 --> 00:10:18,000
Now the only problem is our microservices should be able to read these latest values and we already

149
00:10:18,000 --> 00:10:24,000
know that microservices will only connect with the config server during the startup of the application.

150
00:10:24,000 --> 00:10:30,000
Now, in order to reflect these latest properties, we need to restart the microservices instances and

151
00:10:30,000 --> 00:10:36,000
we are trying to avoid that process because we need to avoid restarting our microservices applications

152
00:10:36,000 --> 00:10:40,000
as it will impact the traffic and as it involves manual process.

153
00:10:40,000 --> 00:10:42,000
So how to overcome this challenge?

154
00:10:42,000 --> 00:10:48,000
Like I said, actuator is going to expose an API with the name refresh.

155
00:10:48,000 --> 00:10:56,000
If you go to the accounts actuator like localhost:8080/actuator against this actuator, you will be

156
00:10:56,000 --> 00:10:58,000
having lot many APIs exposed.

157
00:10:58,000 --> 00:11:01,000
And here just look for refresh.

158
00:11:01,000 --> 00:11:02,000
So this is the path.

159
00:11:02,000 --> 00:11:07,000
If I try to invoke this, it is saying method not allowed because from the browser, always the history

160
00:11:07,000 --> 00:11:09,000
http get method will be invoked.

161
00:11:09,000 --> 00:11:12,000
But this refresh API supports only the post method.

162
00:11:12,000 --> 00:11:16,000
So that's why we need to go to the postman to invoke this refresh API.

163
00:11:16,000 --> 00:11:22,000
Before that, let me invoke all the contact info one more time inside my microservices to make sure

164
00:11:22,000 --> 00:11:26,000
the properties are not reflected as of now inside the microservices.

165
00:11:26,000 --> 00:11:29,000
So for loans you can see the same old prod is there.

166
00:11:29,000 --> 00:11:33,000
Similarly for accounts, the same old one is there.

167
00:11:33,000 --> 00:11:34,000
And now for cards

168
00:11:34,000 --> 00:11:36,000
I'm trying to invoke for this

169
00:11:36,000 --> 00:11:39,000
also, the same old prod value is here.

170
00:11:39,000 --> 00:11:46,000
As a next step, we need to invoke the actuator refresh URL for the same inside the accounts folder.

171
00:11:46,000 --> 00:11:50,000
You can see there is a request with the name refresh config.

172
00:11:50,000 --> 00:11:51,000
So let me click on this.

173
00:11:51,000 --> 00:11:56,000
You can see this is the URL that we need to invoke since we are trying to refresh the config of accounts

174
00:11:56,000 --> 00:12:03,000
microservice, we need to use the endpoint URL of accounts microservice instance like 

175
00:12:03,000 --> 00:12:06,000
localhost:8080/actuator/refresh by default.

176
00:12:06,000 --> 00:12:10,000
This URL is never exposed inside your microservices.

177
00:12:10,000 --> 00:12:16,000
Since we have mentioned these configuration, inside all the microservices, all the management endpoints

178
00:12:16,000 --> 00:12:17,000
are being exposed.

179
00:12:17,000 --> 00:12:23,000
If you want to expose only refresh, you need to mention refresh here, but I want to go with Asterisk

180
00:12:24,000 --> 00:12:28,000
because in the coming sections we need to enable many other management endpoints.

181
00:12:28,000 --> 00:12:29,000
I hope you are clear.

182
00:12:29,000 --> 00:12:32,000
Now I'm trying to invoke this API.

183
00:12:32,000 --> 00:12:35,000
There is no need to send any request to data inside the body.

184
00:12:35,000 --> 00:12:39,000
It can be empty, but please make sure the Http method is post.

185
00:12:39,000 --> 00:12:41,000
I'm trying to click on the send button.

186
00:12:41,000 --> 00:12:48,000
You will get a response from your refresh API saying that accounts.message property is changed and

187
00:12:48,000 --> 00:12:51,000
the same right now is being refreshed behind the scenes.

188
00:12:51,000 --> 00:12:56,000
Apart from accounts.message, we are also getting one more property which is config.client.version

189
00:12:56,000 --> 00:12:57,000
.

190
00:12:57,000 --> 00:13:03,000
So you will always get these property whenever you change something on the GitHub repo because whenever

191
00:13:03,000 --> 00:13:08,000
a change happens, your config server is going to change the version number behind the scenes and the

192
00:13:08,000 --> 00:13:13,000
same it is trying to send to the config client applications like accounts microservice.

193
00:13:13,000 --> 00:13:19,000
We need to worry about this message only because this is the message which is going to impact our business

194
00:13:19,000 --> 00:13:19,000
logic.

195
00:13:19,000 --> 00:13:21,000
So now we refresh it.

196
00:13:21,000 --> 00:13:24,000
I'll go to the contact-info of accounts microservice.

197
00:13:24,000 --> 00:13:27,000
So this is the contact info of accounts

198
00:13:27,000 --> 00:13:29,000
microservice I have not restarted my accounts

199
00:13:29,000 --> 00:13:32,000
microservice. Are you ready to see the magic?

200
00:13:32,000 --> 00:13:34,000
As of now you can see the value here is prod.

201
00:13:34,000 --> 00:13:38,000
As soon as I click on the send button it is changed to the production API.

202
00:13:38,000 --> 00:13:45,000
That means we are able to change the property value runtime without restarting our accounts

203
00:13:45,000 --> 00:13:46,000
microservice.

204
00:13:46,000 --> 00:13:50,000
Now similar activity I have to do for loans and cards also.

205
00:13:50,000 --> 00:13:55,000
Now if you go and test the loans microservice, you can see it is still referring to the prod because

206
00:13:55,000 --> 00:14:00,000
we have not invoked the refresh API available against the loans microservice.

207
00:14:00,000 --> 00:14:06,000
So for the same, let's go to the loans folder and click on this refresh config and post that you can

208
00:14:06,000 --> 00:14:08,000
click on the send button.

209
00:14:08,000 --> 00:14:11,000
You will get the message saying that loans.message is changed behind the scenes.

210
00:14:11,000 --> 00:14:17,000
Now if you go to the contact-info and try to invoke this time, you'll get the production APIs.

211
00:14:17,000 --> 00:14:20,000
Let me do the same for cards also. For the same,

212
00:14:20,000 --> 00:14:23,000
first, I need to invoke this refresh config present under the cards.

213
00:14:23,000 --> 00:14:30,000
Once I get this response, I can go to the contact-info of cards and here I'm trying to click on this

214
00:14:30,000 --> 00:14:30,000
send button.

215
00:14:30,000 --> 00:14:33,000
You can see I'm getting the production as an output.

216
00:14:33,000 --> 00:14:41,000
I hope you are clear how we can refresh our property values runtime with the help of actuator refresh

217
00:14:41,000 --> 00:14:41,000
endpoint.

218
00:14:41,000 --> 00:14:45,000
Let's try to revise the steps that we followed very quickly here.

219
00:14:45,000 --> 00:14:50,000
I have mentioned all these steps that we have followed inside this slide so that it will act as a reference

220
00:14:50,000 --> 00:14:50,000
for you.

221
00:14:50,000 --> 00:14:56,000
The very first step that we need to follow is, we need to add the spring boot actuator dependency inside

222
00:14:56,000 --> 00:14:57,000
the pom.xml.

223
00:14:57,000 --> 00:14:59,000
After that, we need to make sure that

224
00:14:59,000 --> 00:15:07,000
actuator is exposing the refresh endpoint by adding the property management.endpoints.web.exposure

225
00:15:07,000 --> 00:15:10,000
include is equal to refresh instead of refresh.

226
00:15:10,000 --> 00:15:16,000
You can also mention asterisk value. Post that whenever you want to refresh your properties inside your

227
00:15:16,000 --> 00:15:22,000
accounts microservices or any other microservices without restart, you need to simply invoke the

228
00:15:22,000 --> 00:15:28,000
actuator path, which is actuator/refresh against your microservices instance.

229
00:15:28,000 --> 00:15:30,000
So let's try to visualize this.

230
00:15:30,000 --> 00:15:34,000
So you can see here in the very first step, we are going to push the new configuration data into the

231
00:15:34,000 --> 00:15:41,000
config repo post that we are going to invoke these actuator/refresh using the Http post method.

232
00:15:41,000 --> 00:15:45,000
So I'm trying to give a demo using the account microservice here.

233
00:15:45,000 --> 00:15:51,000
So now my account microservice behind the scenes it will ask the configuration server to give the property

234
00:15:51,000 --> 00:15:54,000
values which are changed compared to the previous version.

235
00:15:54,000 --> 00:16:00,000
So my config server it will go and try to pull all the latest changes from the GitHub repo in the in

236
00:16:00,000 --> 00:16:06,000
the step four and the same it will try to send back to the accounts microservice by following the step

237
00:16:06,000 --> 00:16:12,000
five and step six. And at last, since my account microservice is going to receive the property details

238
00:16:12,000 --> 00:16:18,000
which are changed, it is going to read them from the config server inside the step seven by reloading

239
00:16:18,000 --> 00:16:23,000
all the new configurations into the microservices without restarting of the application.

240
00:16:23,000 --> 00:16:25,000
So this is super, super perfect.

241
00:16:25,000 --> 00:16:29,000
But there is a serious drawback that we have inside this approach.

242
00:16:29,000 --> 00:16:35,000
The drawback is think like you have 100 microservices and each of them has five different instances,

243
00:16:35,000 --> 00:16:41,000
which means there will be total 500 microservices instances running inside your production.

244
00:16:41,000 --> 00:16:46,000
And for some reason you're trying to change the property in all the microservices.

245
00:16:46,000 --> 00:16:55,000
Then you need to invoke the refresh endpoint against all the 500 instances running inside your production.

246
00:16:55,000 --> 00:16:59,000
And doing this manually is going to be super, super cumbersome process.

247
00:16:59,000 --> 00:17:02,000
Some operations team are some platform team,

248
00:17:02,000 --> 00:17:09,000
they will try to automate this process by writing some scripts inside the CI/CD pipelines or they will

249
00:17:09,000 --> 00:17:16,000
try to write a Jenkins jobs or CI/CD jobs, which will invoke all the microservices instances, refresh

250
00:17:16,000 --> 00:17:16,000
and points.

251
00:17:16,000 --> 00:17:21,000
But still, it may not be a convenient solution for many projects.

252
00:17:21,000 --> 00:17:28,000
That's why let's explore this further and try to identify is there any better option that we have to

253
00:17:28,000 --> 00:17:36,000
refresh the properties dynamically without invoking this refresh endpoint for each and every microservice

254
00:17:36,000 --> 00:17:36,000
instance.

255
00:17:36,000 --> 00:17:37,000
I hope you are clear.

256
00:17:37,000 --> 00:17:40,000
Thank you and I'll catch you in the next lecture bye.


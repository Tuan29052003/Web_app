1
00:00:00,000 --> 00:00:01,000
Inside this lecture,

2
00:00:01,000 --> 00:00:06,000
let's try to learn more details about what is Kubernetes ingress?

3
00:00:06,000 --> 00:00:11,000
Before I try to explain more about Ingress, first, let me clarify you the difference between the LoadBalancer

4
00:00:11,000 --> 00:00:14,000
service type and Kubernetes Ingress.

5
00:00:14,000 --> 00:00:21,000
So whenever you are using service type as LoadBalancer, you are going to expose a particular microservice

6
00:00:21,000 --> 00:00:28,000
to which you are tagging the service type as LoadBalancer to the outside of your Kubernetes cluster.

7
00:00:28,000 --> 00:00:34,000
So if you use service type as LoadBalancer for five different microservices, then all of them they

8
00:00:34,000 --> 00:00:41,000
are going to have five different public IPS with their own LoadBalancer provided by your cloud provider.

9
00:00:41,000 --> 00:00:48,000
That means your service type, which is LoadBalancer, is going to be specific for each microservice,

10
00:00:48,000 --> 00:00:55,000
but sometimes we may want to have a single entry point into our Kubernetes cluster, which is going

11
00:00:55,000 --> 00:01:01,000
to take care of forwarding all the external requests to the to one of the container or microservice

12
00:01:01,000 --> 00:01:03,000
available within the cluster.

13
00:01:03,000 --> 00:01:07,000
We already built such component with the help of Spring Cloud Gateway.

14
00:01:07,000 --> 00:01:13,000
So Spring Cloud Gateway is right now acting as a edge server inside our microservice network.

15
00:01:13,000 --> 00:01:19,000
But whatever we have built with the help of Spring Cloud Gateway, this is more of a developer approach.

16
00:01:19,000 --> 00:01:22,000
The developer has to do a lot of configurations.

17
00:01:22,000 --> 00:01:28,000
He has to build a spring boot application by using the spring cloud gateway dependencies and any cross-cutting

18
00:01:28,000 --> 00:01:32,000
concerns, the developer has to implement them with his own hands.

19
00:01:32,000 --> 00:01:38,000
But some organizations, instead of building their own edge server with the help of Spring Cloud Gateway,

20
00:01:38,000 --> 00:01:41,000
they are going to rely on the Kubernetes ingress.

21
00:01:41,000 --> 00:01:45,000
So with this, it should have been clear for you what is Kubernetes Ingress?

22
00:01:45,000 --> 00:01:53,000
So Ingress exposes all the Http and Http routes that are coming from the outside world to the services

23
00:01:53,000 --> 00:01:54,000
within the cluster.

24
00:01:54,000 --> 00:02:01,000
In other words, it is going to act as an edge server inside your microservices and it is going to be

25
00:02:01,000 --> 00:02:07,000
responsible for the traffic routing controlled by the rules defined on the ingress resource.

26
00:02:07,000 --> 00:02:14,000
And if needed, Ingress is also capable of load balancing the traffic, terminating SSL and TLS traffic

27
00:02:14,000 --> 00:02:17,000
and offer name based virtual hosting.

28
00:02:17,000 --> 00:02:21,000
So Ingress has many capabilities using those capabilities,

29
00:02:21,000 --> 00:02:27,000
you can also enforce some cross-cutting concerns authentication and authorization with the help of ingress

30
00:02:27,000 --> 00:02:32,000
by integrating with the Oauth2 or Oidc products like Keycloak or Okta.

31
00:02:32,000 --> 00:02:35,000
So like I said, there are many capabilities of ingress.

32
00:02:35,000 --> 00:02:41,000
And here you may have a great question, which is if both Spring Cloud, gateway and Ingress are going

33
00:02:41,000 --> 00:02:47,000
to do the similar job, then what is the need for the developer to build an edge server with the help

34
00:02:47,000 --> 00:02:48,000
of Spring Cloud Gateway?

35
00:02:48,000 --> 00:02:54,000
Why can't we always go with the ingress component available inside the Kubernetes cluster?

36
00:02:54,000 --> 00:02:57,000
So to answer your question, I have two points to highlight.

37
00:02:57,000 --> 00:03:04,000
The very first one is every organization will have different, different team structures inside an organization.

38
00:03:04,000 --> 00:03:10,000
There can be some super talented developers who are capable of building an edge server with the help

39
00:03:10,000 --> 00:03:11,000
of Spring Cloud Gateway.

40
00:03:11,000 --> 00:03:19,000
In such scenarios, people will incline to the approach of Spring Cloud Gateway, whereas in some organization

41
00:03:19,000 --> 00:03:25,000
there can be some super, super talented DevOps team members who knows everything about Kubernetes cluster,

42
00:03:25,000 --> 00:03:31,000
how to set up a Kubernetes ingress and how to integrate with various products like Keycloak for security

43
00:03:31,000 --> 00:03:36,000
and how to enforce some cross-cutting concerns everything with the help of Kubernetes.

44
00:03:36,000 --> 00:03:36,000
Ingress.

45
00:03:36,000 --> 00:03:42,000
So if you have such talented team who knows everything about Kubernetes Ingress and how to set up that,

46
00:03:42,000 --> 00:03:49,000
then in such scenarios, obviously the project leadership, they will incline towards the Kubernetes

47
00:03:49,000 --> 00:03:50,000
ingress approach.

48
00:03:50,000 --> 00:03:56,000
These two approaches like Spring Cloud Gateway and Kubernetes Ingress, they both does the same job.

49
00:03:56,000 --> 00:04:01,000
It's just that at the end of the day, the organization has to take a decision whether you want to put

50
00:04:01,000 --> 00:04:08,000
this responsibility of exposing the traffic to the outside world at the developer hand or at the DevOps

51
00:04:08,000 --> 00:04:09,000
team members hand.

52
00:04:09,000 --> 00:04:15,000
So based upon that, accordingly, people will choose either Spring Cloud Gateway or Kubernetes ingress

53
00:04:15,000 --> 00:04:15,000
approach.

54
00:04:15,000 --> 00:04:17,000
So that's a very first point that I want to highlight.

55
00:04:17,000 --> 00:04:23,000
The second point is sometimes ingress may not be the go to answer for all your problems.

56
00:04:23,000 --> 00:04:29,000
The developer want to write some business logic which cannot be achieved by the Kubernetes ingress.

57
00:04:29,000 --> 00:04:35,000
So in such scenarios, obviously the option is to go with the spring Cloud Gateway because Spring Cloud

58
00:04:35,000 --> 00:04:41,000
Gateway has a lot of flexibility provided where the developer can write the custom business logic with

59
00:04:41,000 --> 00:04:43,000
the Java programming language.

60
00:04:43,000 --> 00:04:48,000
So it all depends upon the scenario you are into and what kind of organization you are going to work.

61
00:04:48,000 --> 00:04:54,000
So I hope you are clear with the difference between ingress and Spring Cloud gateway approach.

62
00:04:54,000 --> 00:04:59,000
So now let's try to understand more details about Ingress, so how the DevOps team members are going

63
00:04:59,000 --> 00:05:00,000
to deal.

64
00:05:00,000 --> 00:05:03,000
Find the routing requirements with the help of ingress.

65
00:05:03,000 --> 00:05:09,000
So for the same you can see I have given a sample snippet. Here the very first important information

66
00:05:09,000 --> 00:05:16,000
that that I want you to observe is kinds. After the kind element we have mentioned that value as ingress.

67
00:05:16,000 --> 00:05:22,000
So with this, it's clearly an indication to the Kubernetes cluster that this specification related

68
00:05:22,000 --> 00:05:23,000
to the Kubernetes ingress.

69
00:05:23,000 --> 00:05:27,000
Now, you already know what is the purpose of metadata name.

70
00:05:27,000 --> 00:05:32,000
Moving on to the specification, there is a element that we need to write, which is rules.

71
00:05:32,000 --> 00:05:39,000
Inside these rules we can provide what is the base host name of our organization and that you can provide

72
00:05:39,000 --> 00:05:41,000
various path configurations.

73
00:05:41,000 --> 00:05:47,000
Like if someone is trying to access so-and-so path, what is the backend service inside the Kubernetes

74
00:05:47,000 --> 00:05:47,000
cluster,

75
00:05:47,000 --> 00:05:49,000
you want to forward the request.

76
00:05:49,000 --> 00:05:55,000
So all those details, the DevOps team members, they can configure using these kind of Kubernetes ingress

77
00:05:55,000 --> 00:05:56,000
configurations.

78
00:05:56,000 --> 00:06:01,000
I just gave a sample configuration for your reference, but like I said, you don't need to learn or

79
00:06:01,000 --> 00:06:07,000
remember all these things because these are all the responsibilities of DevOps team member or a person

80
00:06:07,000 --> 00:06:12,000
who is responsible to set up Kubernetes components inside your organization.

81
00:06:12,000 --> 00:06:19,000
So with the help of Ingress, we are only going to define the configurations or our own requirements.

82
00:06:19,000 --> 00:06:25,000
At the end of the day, there should be a component which is responsible to implement all these ingress

83
00:06:25,000 --> 00:06:28,000
requirements that we have defined. For the same,

84
00:06:28,000 --> 00:06:31,000
we have a component called IngressController.

85
00:06:31,000 --> 00:06:36,000
So by default, ingress resource can't do anything based upon our configurations.

86
00:06:36,000 --> 00:06:43,000
We need to have an IngressController installed on configure inside your Kubernetes cluster to make

87
00:06:43,000 --> 00:06:45,000
ingress resources functional.

88
00:06:45,000 --> 00:06:50,000
So there are many, many popular IngressControllers available inside the market.

89
00:06:50,000 --> 00:06:57,000
Few such famous IngressControllers are nginx, ingress traffic and proxy ingress.

90
00:06:57,000 --> 00:07:05,000
So the job of these controllers is they should watch for the ingress resources and configure the underlying

91
00:07:05,000 --> 00:07:09,000
network components accordingly inside the Kubernetes cluster.

92
00:07:09,000 --> 00:07:14,000
So if you want to understand what the full list of ingress controllers available, you can visit this

93
00:07:14,000 --> 00:07:20,000
page. Like you can see here, Kubernetes officially published in their documentation that these are all

94
00:07:20,000 --> 00:07:22,000
the supported ingress controllers.

95
00:07:22,000 --> 00:07:27,000
And here there are more than 30 ingress controllers and organizations

96
00:07:27,000 --> 00:07:31,000
they use these controllers based upon their own custom requirements.

97
00:07:31,000 --> 00:07:32,000
Here

98
00:07:32,000 --> 00:07:36,000
if you search for nginx, there is a nginx Ingress Controller.

99
00:07:36,000 --> 00:07:41,000
This is the most commonly used controller because it is an open sourced controller.

100
00:07:41,000 --> 00:07:45,000
So this is built and maintained by the Nginx team.

101
00:07:45,000 --> 00:07:50,000
So similarly there are many other controllers which we don't need to deep dive into them and understand

102
00:07:50,000 --> 00:07:57,000
them because it's a job of Kubernetes admin to set up the ingress controller inside the Kubernetes cluster.

103
00:07:57,000 --> 00:07:57,000
As a next step,

104
00:07:57,000 --> 00:08:04,000
let me show you a sample representation of how the traffic is going to flow inside Kubernetes cluster.

105
00:08:04,000 --> 00:08:09,000
Whenever you are using Kubernetes Ingress. Like you can see here, first we are going to have a Kubernetes

106
00:08:09,000 --> 00:08:11,000
cluster inside that,

107
00:08:11,000 --> 00:08:13,000
we are going to have Kubernetes pods.

108
00:08:13,000 --> 00:08:18,000
Inside the pods, we are going to deploy the containers like accounts, loans and cards.

109
00:08:18,000 --> 00:08:22,000
So all of them are not exposed to the outside of the Kubernetes cluster.

110
00:08:22,000 --> 00:08:27,000
So all these services are exposed with the help of ClusterIP service.

111
00:08:27,000 --> 00:08:34,000
So anyone who wants to access these services, either internally or from external traffic, they need

112
00:08:34,000 --> 00:08:40,000
to reach out to the service objects which are forward the request to the corresponding container.

113
00:08:40,000 --> 00:08:45,000
So whenever we are trying to deploy our accounts microservice behind the scenes, we are also going

114
00:08:45,000 --> 00:08:48,000
to create a service definition with a cluster IP service.

115
00:08:48,000 --> 00:08:53,000
So anyone who wants to talk with the accounts microservice containers, they should reach out to

116
00:08:53,000 --> 00:08:54,000
the account service.

117
00:08:54,000 --> 00:08:57,000
With this setup, only the components within the Kubernetes cluster

118
00:08:57,000 --> 00:09:01,000
they can talk with the accounts, loans and cards, microservice.

119
00:09:01,000 --> 00:09:07,000
Now let's try to understand how this is going to change when we introduce Kubernetes Ingress.

120
00:09:07,000 --> 00:09:11,000
So with the help of a IngressController, you can see the Kubernetes developers.

121
00:09:11,000 --> 00:09:17,000
They can define many routing rules inside the using ingress resource configuration.

122
00:09:17,000 --> 00:09:21,000
Here you can see I have a sample domain with the name Example.com.

123
00:09:21,000 --> 00:09:27,000
And if someone is trying to access this domain with the Path accounts, it is going to be redirected

124
00:09:27,000 --> 00:09:32,000
to one of the back end service inside the Kubernetes cluster available at the account service.

125
00:09:32,000 --> 00:09:38,000
Once the request is received by the account service, it is going to take care of forwarding the request

126
00:09:38,000 --> 00:09:42,000
to one of the ports where the accounts microservice container is deployed.

127
00:09:42,000 --> 00:09:46,000
So the same applies for other microservices and other paths like loans and cards.

128
00:09:46,000 --> 00:09:53,000
So when we have this Kubernetes ingress controller, any external client, they can forward the request

129
00:09:53,000 --> 00:09:55,000
to the Ingress-managed load balancer.

130
00:09:55,000 --> 00:10:00,000
And this load balancer can redirect the traffic to the one of the ingress controler.

131
00:10:00,000 --> 00:10:07,000
Because there is also a possibility that your organization may set up multiple instances of ingress

132
00:10:07,000 --> 00:10:07,000
controller.

133
00:10:07,000 --> 00:10:13,000
In such scenarios, there will be a load balancer which is managed by the ingress and the responsibility

134
00:10:13,000 --> 00:10:14,000
of that ingress

135
00:10:14,000 --> 00:10:20,000
manage load balancer is to redirect the traffic to the one of the ingress controller instance.

136
00:10:20,000 --> 00:10:25,000
From there, the traffic will reach to the service from service to parts, from parts to container.

137
00:10:25,000 --> 00:10:30,000
So this is how the traffic is going to work whenever we are using Kubernetes ingress.

138
00:10:30,000 --> 00:10:35,000
So this is very similar to Spring Cloud gateway approach inside the Spring Cloud Gateway

139
00:10:35,000 --> 00:10:40,000
also, it is going to act as an edge server for our Kubernetes cluster. Very similarly here

140
00:10:40,000 --> 00:10:47,000
also, the Kubernetes ingress controller is going to act as a entry point or as an edge server for your

141
00:10:47,000 --> 00:10:49,000
Kubernetes cluster.

142
00:10:49,000 --> 00:10:54,000
I hope you are clear with all the discussions around the Kubernetes ingress, we are going to discuss

143
00:10:54,000 --> 00:10:56,000
few more details about Ingress in the next lecture.

144
00:10:56,000 --> 00:10:59,000
Thank you and I'll catch you in the next lecture.

145
00:10:59,000 --> 00:10:59,000
Bye.

